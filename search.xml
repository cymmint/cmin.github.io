<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JS实现圆周运动]]></title>
      <url>%2Fblog%2F2018-09%2FJS%2Fcircular-motion%2F</url>
      <content type="text"><![CDATA[JS实现圆周运动，其实都是由简单的知识变化而来的，所以这里讲的圆周运动也是离不开三角函数的。 了解三角函数正弦（sin） = 对边/斜边余弦（cos） = 邻边/斜边正切（tan） = 对边/邻边余切（cot） = 邻边/对边 在JS中：Math.sin(x) x 的正玄值。返回值在 -1.0 到 1.0 之间；Math.cos(x) x 的余弦值。返回的是 -1.0 到 1.0 之间的数；这两个函数中的 x 都是指的“弧度”而非“角度”，弧度的计算公式为： 2 * PI / 360 * 角度 因此，如果要计算30°角度的弧度，由上公式可得：PI / 180 * 30 圆弧轨迹坐标如何得到圆弧轨迹的每个坐标点呢？解决思路：根据三角形的正玄、余弦来得值；假设一个圆的圆心坐标是(cx, cy)，半径为r，弧度为 angle，则圆弧每个坐标点的(x, y)：x = Math.sin(angle * 2 * Math.PI / 360) * ry = Math.cos(angle * 2 * Math.PI / 360) * r 代码实现方法JS12345678910111213141516171819202122232425$(window).on('load', function() &#123; var cx = 300; //圆心坐标X var cy = 300; //圆心坐标Y var r = 100; //半径 var angle = 0; //运动轨迹角度 0~360 var T = setInterval(function() &#123; ++angle; var x = Math.sin(angle * Math.PI / 180) * r; //运动弧度坐标x var y = Math.cos(angle * Math.PI / 180) * r; //运动弧度坐标y var $dot = $('&lt;span class="dot"&gt;&lt;span&gt;'); console.log(x, y); $dot.css(&#123;left: cx + x, top: cy - y&#125;); //顶上顺时针 /** * 变化 * cx,cy 分别加减x,y，圆弧的运动的起点方位、方向会发生变化 */ //$dot.css(&#123;left: cx - x, top: cy - y&#125;); //顶上逆时针 $('body').append($dot); if(angle &gt; 360) &#123; clearInterval(T); &#125; &#125;, 10);&#125;); CSS1234567.dot &#123; position:absolute; width:6px; height:6px; background-color:red; border-radius:100%;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3圆形轨迹移动动画]]></title>
      <url>%2Fblog%2F2018-09%2FCSS%2Fcss3-circle%2F</url>
      <content type="text"><![CDATA[功能用CSS3圆形轨迹移动动画，主要是设置贝塞尔曲线值为 cubic-bezier(0.36,0,0.64,1)，其它就是正常CSS3动画操作。 CSS123456789101112131415161718192021222324252627@keyframes animX&#123; 0% &#123;left: 0;&#125; 100% &#123;left: 500px;&#125;&#125;@keyframes animY&#123; 0% &#123;top: 0;&#125; 100% &#123;top: 500px;&#125;&#125;#ball &#123; width: 20px; height: 20px; background-color: #f66; border-radius: 50%; position: absolute; animation: animX 4s cubic-bezier(0.36,0,0.64,1) -2s infinite alternate, animY 4s cubic-bezier(0.36,0,0.64,1) 0s infinite alternate;&#125;#loop &#123; width:498px; height:498px; border:2px solid #999; border-radius:50%; position:absolute; left:9px; top:9px;&#125; HTML12&lt;div id="loop"&gt;&lt;/div&gt;&lt;div id="ball"&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Package.json 文件详解]]></title>
      <url>%2Fblog%2F2017-03%2FIDE%2Fpackage.json-dependencies%2F</url>
      <content type="text"><![CDATA[每个npm的安装包里面都会包含一个package.json，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。 npm install 命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。package.json文件可以手工编写，也可以使用npm init命令自动生成，这个命令采用互动方式，要求用户回答一些问题，然后在当前目录生成一个基本的package.json文件。所有问题之中，只有项目名称（name）和项目版本（version）是必填的，其他都是选填的。 一个简单的package.json文件1234&#123; "name": "xxx", "version": "0.0.0",&#125; 上面代码说明， package.json 文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。比如 name 就是项目名称， version 是版本（遵守“大版本.次要版本.小版本”的格式）。 一个完整的package.json1234567891011121314151617181920212223242526272829303132333435363738&#123; "name": "Hello World", "version": "0.0.1", "author": "张三", "description": "第一个node.js程序", "scripts": &#123; "start": "node index.js" &#125;, "keywords": [ "node.js", "javascript" ], "repository": &#123; "type": "git", "url": "https://path/to/url" &#125;, "license": "MIT", "engines": &#123; "node": "0.10.x" &#125;, "bugs": &#123; "url": "http://path/to/bug", "email": "bug@example.com" &#125;, "contributors": [ &#123; "name": "李四", "email": "lisi@example.com" &#125; ], "dependencies": &#123; "express": "latest" &#125;, "devDependencies": &#123; "bower": "~1.2.8", "grunt": "~0.4.1" &#125;&#125; 下面详细解释package.json文件的各个字段。 bin 字段bin项用来指定各个内部命令对应的可执行文件的位置。123"bin": &#123; "someTool": "./bin/someTool.js"&#125; main 字段main 字段指定了加载该模块时的入门文件，默认是模块根目录下面的 index.js scripts 字段 scripts 指定了运行脚本命令的npm命令行缩写，比如start指定了运行 npm run start 时，所要执行的命令。 例如下面的设置指定了 npm run preinstall 、 npm run postinstall 、 npm run start 、 npm run test 时，所要执行的命令。123456"scripts": &#123; "preinstall": "echo here it comes!", "postinstall": "echo there it goes!", "start": "node index.js", "test": "tap test/*.js"&#125; devDependencies, dependencies 字段我们在使用npm install 安装模块或插件的时候，有两种命令把他们写入到 package.json 文件里面去，比如：--save 对应 -&gt; 安装到 dependencies 字段--save-dev 对应 -&gt; 安装到 devDependencies 字段devDependencies 和 dependencies 字段实际区别是：devDependencies 里面的插件只用于开发环境，不用于生产环境，而 dependencies 是需要发布到生产环境的。devDependencies 指定项目开发所需要的模块，dependencies 字段指定了项目运行所依赖的模块。 peerDependencies 字段peerDependencies 字段，就是用来供插件指定其所需要的主工具的版本。123456&#123; "name": "chai-as-promised", "peerDependencies": &#123; "chai": "1.x" &#125;&#125; 上面代码指定，安装 chai-as-promised 模块时，主程序 chai 必须一起安装，而且 chai 的版本必须是 1.x 。如果你的项目指定的依赖是 chai 的2.0版本，就会报错。 config 字段config字段用于向环境变量输出值。下面是一个package.json文件。12345&#123; "name" : "foo", "config" : &#123; "port" : "8080" &#125;, "scripts" : &#123; "start" : "node server.js" &#125;&#125; 然后，在 server.js 脚本就可以引用config字段的值。http.createServer(…).listen(process.env.npm_package_config_port) 用户可以改变这个值$ npm config setfoo:port 80 browser 字段browser指定该模板供浏览器使用的版本。Browserify这样的浏览器打包工具，通过它就知道该打包那个文件。123"browser": &#123; "tipso": "./node_modules/tipso/src/tipso.js"&#125; engines 字段engines指明了该项目所需要的node.js版本。 man 字段man用来指定当前模块的man文档的位置。1"man" :[ "./doc/calc.1" ] preferGlobal字段preferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。 style字段style指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。123"style": [ "./node_modules/tipso/src/tipso.css"] Author, contributors 字段都是可选字段。author是一个人，contributors是一组人。 license 字段你应该要指定一个许可证，让人知道使用的权利和限制的。 description 字段项目简介。 keywords 字段关键字。 homepage 字段项目官网的url。 bugs 字段项目的提交问题的url和（或）邮件地址。 插件版本限定版本号 x.y.z ： x 表示一些设计的变动及模块的重构之类的，会升级x版本号 y 表示一些大的版本更改，比如一些API的变化 z 表示一些小的bug fix, 更改z的号 在package.json里面dependencies依赖包的版本号前面的符号有两种，一种是~，一种是^。~: 是匹配最近的小版本 比如~1.0.2 将会匹配所有 1.0.x版本，但不匹配1.1.0^: 是最近的一个大版本 比如^1.0.2 将会匹配所有 1.x.x, 但不包括2.x.x无~ ^: 则安装时只安装指定版本latest: 安装最新版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS日常经验杂谈]]></title>
      <url>%2Fblog%2F2017-01%2FCSS%2Fexperience%2F</url>
      <content type="text"><![CDATA[IE下Table与浮动层处于同级时，浮动失效解决方法 为浮动层设置背景 background:url(about:blank);设置一个不是背景的背景 iOS中textbox文本框清除圆角在iOS、Mac safari中，所有的textbox, select, checkbox都会被强制美化为圆角。但在特殊情况下需要清除圆角时发现iOS中使用以下传统的css无效。 解决方法：border-radius:0; -webkit-appearance:none;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[去除chrome表单自动填充淡黄色背景]]></title>
      <url>%2Fblog%2F2017-01%2FCSS%2Fwebkit-autofill%2F</url>
      <content type="text"><![CDATA[利用CSS -webkit-autofill属性利用内阴影颜色覆盖自动填充背景色，但如果input必须设置为无背景效果就不是很好了 123input:-webkit-autofill &#123; -webkit-box-shadow: 0 0 0 50px white inset;&#125; 利用HTML表单属性关闭表单自动完成属性 autocomplete=”off”（此方法好像没有效果） 利用JS是遍历需要执行的Input标签，然后插入自身DOM（插入其它的不行），在其获得焦点时删除其子节点，否则在表单提交的时数据可能会有问题 12345678910if (navigator.userAgent.toLowerCase().indexOf("applewebkit") &gt;= 0) &#123; $(window).load(function () &#123; $('input').each(function () &#123; $(this).append(this.outerHTML); &#125;); &#125;); $('input').focus(function () &#123; $(this).children().remove(); &#125;);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS获取服务器时间]]></title>
      <url>%2Fblog%2F2016-11%2FJS%2Fget-server-time%2F</url>
      <content type="text"><![CDATA[用js做时间校正，获取本机时间，是存在bug的。使用JS也可获取到服务器时间，原理是使用 AJAX 请求，返回的头部信息就含有服务器端的时间信息，获取到就可以了。 依赖jQuery1return new Date($.ajax(&#123;async: false&#125;).getResponseHeader("Date")); 以上函数返回的就是一个Date对象，注意在使用ajax时必须同步，要不然无法返回时间日期；无需填写请求链接。 原生JS12345678910111213function getServerDate()&#123; var xhr = null; if(window.XMLHttpRequest)&#123; xhr = new window.XMLHttpRequest(); &#125;else&#123; // ie xhr = new ActiveObject("Microsoft") &#125; xhr.open("GET","/",false); //false不可变 xhr.send(null); var date = xhr.getResponseHeader("Date"); return new Date(date);&#125; 同样返回的是一个Date对象，xhr.open()必须使用同步；无需填写请求链接；open，send，和getResponseHeader 必须按序编写；如需使用异步请求，可监听onreadystatechange状态来做不同的操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS cursor属性值]]></title>
      <url>%2Fblog%2F2016-11%2FCSS%2Fcursor%2F</url>
      <content type="text"><![CDATA[功能简介定义鼠标指针放在一个元素边界范围内时所用的光标形状 属性取值 值 描述 url 需使用的自定义光标的 URL default 默认光标（通常是一个箭头） auto 默认浏览器设置的光标 crosshair 光标呈现为十字线 pointer 光标呈现为指示链接的指针（一只手） move 此光标指示某对象可被移动 e-resize 此光标指示矩形框的边缘可被向右（东）移动 ne-resize 此光标指示矩形框的边缘可被向上及向右移动（北/东） nw-resize 此光标指示矩形框的边缘可被向上及向左移动（北/西） n-resize 此光标指示矩形框的边缘可被向上（北）移动 se-resize 此光标指示矩形框的边缘可被向下及向右移动（南/东） sw-resize 此光标指示矩形框的边缘可被向下及向左移动（南/西） s-resize 此光标指示矩形框的边缘可被向下移动（南） w-resize 此光标指示矩形框的边缘可被向左移动（西） text 此光标指示文本 wait 此光标指示程序正忙（通常是一只表或沙漏） help 此光标指示可用的帮助（通常是一个问号或一个气球） 效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于像素的一些概念]]></title>
      <url>%2Fblog%2F2016-09%2FIDE%2Fabout-pixels%2F</url>
      <content type="text"><![CDATA[在进行具体的分析之前，首先得知道下面这些关键性基本概念。 物理像素(physical pixel)一个物理像素是显示器(手机屏幕)上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。 设备独立像素(density-independent pixel)设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。所以说，物理像素和设备独立像素之间存在着一定的对应关系，这就是接下来要说的设备像素比。 设备像素比(device pixel ratio )设备像素比(简称dpr)定义了物理像素和设备独立像素的对应关系，它的值可以按如下的公式的得到：设备像素比 = 物理像素 / 设备独立像素 // 在某一方向上，x方向或者y方向 在javascript中，可以通过 window.devicePixelRatio 获取到当前设备的dpr。在css中，可以通过 -webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio 进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。 综合上面几个概念，一起举例说明下：以iphone6为例： 设备宽高为375×667，可以理解为设备独立像素(或css像素)。 dpr为2，根据上面的计算公式，其物理像素就应该×2，为750×1334。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[seajs的安装使用]]></title>
      <url>%2Fblog%2F2016-09%2FIDE%2Fseajs-install%2F</url>
      <content type="text"><![CDATA[Sea.js 追求简单、自然的代码书写和组织方式，具有以下核心特性： 简单友好的模块定义规范：Sea.js 遵循 CMD 规范，可以像 Node.js 一般书写模块代码。 自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。 安装使用npm install spm -gspm install seajs 配置1234567891011121314151617seajs.config(&#123; // 设置路径，方便跨目录调用 map: [ //['/static/', '/lldq/static/'] //发布上线时JS文件路径替换[a &lt;- b] ], base: '/static/js', paths: &#123; "components": '/static/components', "models": '/static/js/models', "sourceCmd": '/static/js/sources-cmd' &#125;, alias: &#123; "jquery": "components/jquery/jquery", "vue": "components/vue/vue", "common": "models/common" &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FIS3 环境搭建]]></title>
      <url>%2Fblog%2F2016-09%2FIDE%2Ffis3-building%2F</url>
      <content type="text"><![CDATA[FIS3 （ 官网地址 ）是面向前端的工程构建工具。解决前端工程中性能优化、资源加载（异步、同步、按需、预加载、依赖管理、合并、内嵌）、模块化开发、自动化工具、开发规范、代码部署等问题。 准备工作 下载 NodeJS 下载 JAVA JDK 安装工具安装 JAVA JDK、NodeJS，选择安装目录即可安装 FIS3当NodeJS安装成功后，在命令窗口内运行 npm -g install fis3，FIS3安装成功后，会出现以下图样 安装 fis3-jello在命令窗口内运行 npm install -g fis3-jello然后 下载demo 文件，在 fis-conf.js 中添加以下代码即可fis.require(&#39;jello&#39;)(fis); 安装相关的插件npm install -g 插件名npm install -g fis-parser-less在fis3里内置了部分插件，如图片压缩、JS压缩（fis-optimizer-png-compressor、fis-optimizer-uglify-js），其它没有的当然需要自己手动安装 调试在 fis-conf.js 所在目录（即项目目录），直接通过 fis3 server start 即可下载 fis-conf.js 配置示例 FIS3 命令 服务fis3 server [start|stop|clean|open] （启动|停止|清除发布夹内容|打开发布文件夹） 预览fis3 release -[w|wL|c] (监听文件变化|监听并自动刷新浏览器|清除编译缓存) 发布fis3 release -d [配置名] 输出路径 参考 FIS3: 安装 jello fis3-jello]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebStorm 自动编译Less配置]]></title>
      <url>%2Fblog%2F2016-07%2FIDE%2Fwebstorm-compile-less%2F</url>
      <content type="text"><![CDATA[首先需要通过 npm 安装 lessnpm install less -g，当然前提是你要先安装NodeJS IDE配置C:\Users\Administrator\AppData\Roaming\npm\lessc.cmd此路径是当前用户名下的 设置file &gt; sttings &gt; File watchers &gt; 添加LESS watcher]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5和手机传感器]]></title>
      <url>%2Fblog%2F2016-05%2FJS%2Fmobile-sensors%2F</url>
      <content type="text"><![CDATA[监听手机的设备方向传感器，转化为 background-position 的百分比。 123456789window.DeviceOrientationEvent &amp;&amp; window.addEventListener("deviceorientation", function (event) &#123; document.body.style.backgroundPosition = inRange(event.gamma/.45+50,0,100)+'% ' + inRange((event.beta-45)/.45+50,0,100)+'%';&#125;);function inRange(res,min,max)&#123; res = res&gt;max ? max : res; res = res&lt;min ? min : res; return res;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分秒倒计时]]></title>
      <url>%2Fblog%2F2016-05%2FjQuery%2Fminutes-countdown%2F</url>
      <content type="text"><![CDATA[实现功能 它能实现一个毫秒数值的分秒倒计时，适用场景：比如一个定时待支付订单还有多少秒自动关闭的时间提示 源代码HTML1&lt;span class="tags" data-ms="正整数毫秒"&gt;&lt;/span&gt; JS1234567891011121314151617181920212223242526272829function timer(elm, callback) &#123; var $time = $(elm); var M = &#123; isNum: function ($this) &#123; var sec = $this.data("ms"); return !isNaN(sec) &amp;&amp; parseInt(sec) &gt; 0 ? parseInt(sec) : 0; &#125;, time: function ($this, sec) &#123; if(--sec &gt; 0) &#123; var m = Math.floor(sec/60), s = Math.floor(sec - m * 60); $this.text((m &gt; 9 ? m : "0" + m) + "分" + (s &gt; 9 ? s : "0" + s) + "秒"); setTimeout(function () &#123; M.time($this, sec); &#125;, 1000); &#125; else &#123; if(typeof callback == 'function') &#123; callback.call(); &#125; &#125; &#125; &#125;; $time.each(function () &#123; var $this = $(this), sec = M.isNum($this); if(sec) &#123; M.time($this, sec); &#125; &#125;);&#125; 调用方法123timer(".tags",function () &#123; //回调方法 console.log('时间到');&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Grunt 安装使用]]></title>
      <url>%2Fblog%2F2016-03%2FIDE%2Fgrunt-install%2F</url>
      <content type="text"><![CDATA[本文介绍的是Windows下的安装方法 Grunt 和 Grunt 插件是通过 npm 安装并管理的，npm是 Node.js 的包管理器。Grunt 0.4.x 必须配合Node.js &gt;= 0.8.0版本使用。奇数版本号的 Node.js 被认为是不稳定的开发版。在安装 Grunt 前，请确保当前环境中所安装的 npm 已经是最新版本，执行 npm update -g npm 指令进行升级（在某些系统中可能需要 sudo 指令） 安装CLI先将Grunt命令行（CLI）安装到全局环境中npm install -g grunt-cli上述命令执行完后，grunt 命令就被加入到你的系统路径中了，以后就可以在任何目录下执行此命令了注意，安装grunt-cli并不等于安装了 Grunt！Grunt CLI的任务很简单：调用与Gruntfile在同一目录中 Grunt。这样带来的好处是，允许你在同一个系统上同时安装多个版本的 Grunt。这样就能让多个版本的 Grunt 同时安装在同一台机器上。 安装Grunt 、Grunt插件向已经存在的package.json 文件中添加Grunt和grunt插件的最简单方式是通过 npm install **module** --save-dev 命令。此命令不光安装了&lt;module&gt;，还会自动将其添加到devDependencies 配置段中。 将Grunt最新版本安装到项目目录中npm install grunt --save-dev 安装项目需要的Grunt插件例： npm install grunt-contrib-jshint –save-dev 安装 package.json 全部插件可以将 package.json 的插件列表全部安装(前提是已经安装了grunt命令行，项目下有package.json文件)npm install --save-dev Grunt 项目一般需要在你的项目中添加两份文件：package.json 和 Gruntfile。package.json: 此文件被npm用于存储项目的元数据，以便将此项目发布为npm模块Gruntfile: 此文件被命名为 Gruntfile.js 或 Gruntfile.coffee，用来配置或定义任务（task）并加载Grunt插件的 Grunt 执行如果已经配置好package.json 和 Gruntfile 文件的项目了，接下来就很容易拿Grunt练手了：将命令行的当前目录转到项目的根目录下。执行npm install命令安装项目依赖的库。执行 grunt 命令。OK，就是这么简单。还可以通过 grunt –help 命令列出所有已安装的Grunt任务（task） package 依赖包前缀 ~ ^版本号 x.y.z ： x 表示一些设计的变动及模块的重构之类的，会升级x版本号 y 表示一些大的版本更改，比如一些API的变化 z 表示一些小的bug fix, 更改z的号 在package.json里面dependencies依赖包的版本号前面的符号有两种，一种是~，一种是^。~ 的意思是匹配最近的小版本 比如~1.0.2 将会匹配所有 1.0.x版本，但不匹配1.1.0^ 的意思是最近的一个大版本 比如^1.0.2 将会匹配所有 1.x.x, 但不包括2.x.x 一些配置问题解决cssmin压缩默认会删除一些css hack的问题12345678910111213cssmin: &#123; options: &#123; compatibility: 'ie8', //设置兼容模式 noAdvanced: true //取消高级特性 &#125;, minify: &#123; expand: true, //动态扩展 cwd: '../less/', dest: '../css/', src: ['**/*.css', '!**/*.min.css'], ext: '.css' &#125;&#125; 自动刷新页面123grunt.loadNpmTasks('grunt-contrib-watch'); //监视grunt.loadNpmTasks('grunt-contrib-connect'); //配置一个Servergrunt.loadNpmTasks('grunt-livereload'); //自动刷新 自动打开浏览器1grunt.loadNpmTasks(&apos;grunt-open&apos;); //打开浏览器 参考 Grunt快速入门 Windows下安装Grunt CSS压缩默认会删除一些css hack的问题 Grunt-livereload自动刷新 connect+watch自动刷新 附件这是我个人的grunt配置文件，仅供参考，欢迎指正下载Grunt Config]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webkit-overflow-scrolling 属性]]></title>
      <url>%2Fblog%2F2016-03%2FCSS%2Fwebkit-overflow-scrolling%2F</url>
      <content type="text"><![CDATA[webkit-overflow-scrolling 属性-webkit-overflow-scrolling: auto | touchIOS下控制元素在移动设备上是否使用滚动回弹效果，安卓上貌似不存在此问题 1234div &#123; -webkit-overflow-scrolling: auto; /* 当手指从触摸屏上移开，滚动会立即停止 */ -webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */&#125; 一些问题部分手机滚动时有卡顿此问题主要集中在一些低配置手机，DOM渲染跟不上解决方法：使用GPU渲染 12345div &#123; overflow: auto; -webkit-overflow-scrolling: touch; -webkit-transform: translateZ(0px);&#125; 元素设置position属性后不能滑动当给一个元素设置position:absolute | relative后，再增加-webkit-overflow-scrolling:touch属性，此时滑动几次后可能滚动区域会卡主，不能在滑动解决方法：这时给元素增加个z-index值就可以了 123456div &#123; position: absolute; z-index: 1; overflow: auto; -webkit-overflow-scrolling: touch;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原生JS滚动到浏览器底部分页]]></title>
      <url>%2Fblog%2F2016-03%2FJS%2Fscroll-end-paging%2F</url>
      <content type="text"><![CDATA[功能介绍实现功能列表页面滚动到页面底部时，自动加载下一页数据，这种情况移动端非常常见，且此方法适用PC和移动端。Chrome下不能直接用body为包裹层，直接在Body上无法获取ScrollTop的值。 HTML添加123456789&lt;body&gt; &lt;!--包裹层--&gt; &lt;div id="contentPaging"&gt; &lt;!--list--&gt; &lt;ul class="list"&gt;&lt;/ul&gt; &lt;!--此处是pullLoad动态插入位置--&gt; &lt;/div&gt;&lt;/body&gt; CSS添加123456789101112131415161718192021222324/*Loading*/.loading &#123; background-position:0 100%; transform:rotate(0deg); -webkit-transform:rotate(0deg); -webkit-transition-duration:0ms; -webkit-animation-name:loading; -webkit-animation-duration:1.5s; -webkit-animation-iteration-count:infinite; -webkit-animation-timing-function:linear;&#125;@-webkit-keyframes loading &#123; from &#123; -webkit-transform:rotate(0deg); transform:rotate(0deg);&#125; to &#123; -webkit-transform:rotate(360deg); transform:rotate(360deg);&#125;&#125;@keyframes loading &#123; from &#123; transform:rotate(0deg);&#125; to &#123; transform:rotate(360deg);&#125;&#125;/*pull-down loading*/.page-loading &#123; display:none; width:100%; height:.24rem; padding-top:.04rem; background:#eee; text-align:center; overflow:hidden;&#125;.page-loading img &#123; height:.16rem; vertical-align:top;&#125;.page-loading span &#123; display:inline-block; padding:.03rem 0 0 4px; color:#999; font-size:.12rem; line-height:1; vertical-align:top;&#125; JS方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*** * JS plugin pullLoad * Function : 滚动到底部分页 * Version : 1.2 * Author : Cymmint */var pullLoad = &#123; init: function(container, opts) &#123; //初始化 var _this = this; var d = document.createElement("div"); var p = document.createElement("img"); var t = document.createElement("span"); opts.loadId = !!opts.loadId ? opts.loadId : "pageLoading"; opts.loadImgSrc = !!opts.loadImgSrc ? opts.loadImgSrc : "../images/loading.png"; opts.loadImgClass = !!opts.loadImgClass ? opts.loadImgClass : "loading"; opts.loadText = !!opts.loadText ? opts.loadText : "加载中…"; d.setAttribute("class", "page-loading"); d.setAttribute("id", opts.loadId); p.setAttribute("class", opts.loadImgClass); p.setAttribute("src", opts.loadImgSrc); t.innerHTML = opts.loadText; d.appendChild(p); d.appendChild(t); //Param _this.d = &#123;&#125;; _this.d.container = (typeof container === "object" &amp;&amp; container.nodeType == 1) ? container : !!container ? document.getElementById(container) : document.body; _this.d.wrap = pullLoad.d.container.children[0]; //WRAP之后插入Loading _this.insertAfter(d, _this.d.wrap); _this.d.load = document.getElementById(opts.loadId); _this.d.bottomNum = isNaN(opts.bottomNum) ? 0 : parseInt(opts.bottomNum); &#125;, insertAfter: function(nElem, tElem) &#123; //元素后插入 var _par = tElem.parentNode; if(_par.lastChild == tElem) &#123; _par.appendChild(nElem); &#125; else &#123; _par.insertBefore(nElem, tElem.nextSibling); &#125; &#125;, show: function() &#123; //显示加载中 var _this = this; _this.isLoaded = false; _this.d.load.style.display = "block"; &#125;, hide: function() &#123; //隐藏加载中 var _this = this; _this.isLoaded = true; _this.d.load.style.display = "none"; &#125;, isEnd: function() &#123; //到底了? var _this = this; /*console.log("滚动区高: "+ pullLoad.d.container.scrollTop) console.log("可视区高: "+ pullLoad.d.container.clientHeight) console.log("内容区高: "+ pullLoad.d.wrap.offsetHeight)*/ return _this.d.container.scrollTop &gt;= _this.d.wrap.offsetHeight - _this.d.container.clientHeight - _this.d.bottomNum; &#125;, isLoaded: true, //加载完成 load: function(opts) &#123; //加载数据 var _this = this; _this.show(); if(typeof opts.callback === "function") &#123; opts.callback(); &#125; &#125;, scroll: function(opts) &#123; //滚动方式 var _this = this; _this.d.container.addEventListener("scroll", function() &#123; //滚动事件绑定 if(_this.isEnd() &amp;&amp; _this.isLoaded) &#123; _this.load(opts); &#125; &#125;, false); &#125;, main: function(container, opts) &#123; var _this = this; _this.init(container, opts); //初始化Loading Dom _this.scroll(opts); &#125;&#125;; 调用方法123456789101112131415pullLoad.main("payWrap", &#123; //payWrap是包裹层ID loadId: "pageLoading", //loading层效果ID loadImgSrc: "../images/loading.png", //loading图片地址 loadImgClass: "loading", //CSS3 图片旋转的class loadText: "加载中…", //loading层文字 bottomNum: 5, //距离底部多少px时加载 callback: function()&#123; console.log("数据加载……"); //AJAX获取数据，此处只做时间模拟 setTimeout(function()&#123; console.log("加载完成"); pullLoad.hide(); &#125;, 2000); &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS 对象合并]]></title>
      <url>%2Fblog%2F2016-03%2FJS%2Fnative-object-extend%2F</url>
      <content type="text"><![CDATA[从一个对象复制所有的属性到另一个对象是一个常见的操作。今天来介绍一下 ECMAScript5 和 ECMAScript6 中的实现方式。 ECMAS5中使用方法来实现12345678910111213141516171819202122232425262728293031323334353637383940function extend()&#123; var extend, _extend, _isObject; _isObject = function(o)&#123; return Object.prototype.toString.call(o) === '[object Object]'; &#125;; _extend = function self(destination, source) &#123; var property; for (property in destination) &#123; if (destination.hasOwnProperty(property)) &#123; // 若destination[property]和sourc[property]都是对象，则递归 if (_isObject(destination[property]) &amp;&amp; _isObject(source[property])) &#123; self(destination[property], source[property]); &#125; // 若sourc[property]已存在，则跳过 if (source.hasOwnProperty(property)) &#123; continue; &#125; else &#123; source[property] = destination[property]; &#125; &#125; &#125; &#125;; var arr = arguments, result = &#123;&#125;, i; if (!arr.length) &#123; return &#123;&#125; &#125; for (i = arr.length - 1; i &gt;= 0; i--) &#123; if (_isObject(arr[i])) &#123; _extend(arr[i], result); &#125; &#125; arr[0] = result; return result;&#125; ECMAS6中的assign()方法基本用法Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）12345var target = &#123;a: 1&#125;;var source1 = &#123;b: 2&#125;;var source2 = &#123;c: 3&#125;;Object.assign(target, source1, source2);//结果：&#123;a:1, b:2, c:3&#125; Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 如果只有一个参数，Object.assign会直接返回该参数。12var obj = &#123;a: 1&#125;;Object.assign(obj) === obj // true 如果该参数不是对象，则会先转成对象，然后返回。1typeof Object.assign(2) // "object" 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。12Object.assign(undefined) // 报错Object.assign(null) // 报错 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。123let obj = &#123;a: 1&#125;;Object.assign(obj, undefined) === obj // trueObject.assign(obj, null) === obj // true 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。12345var v1 = 'abc';var v2 = true;var v3 = 10;var obj = Object.assign(&#123;&#125;, v1, v2, v3);console.log(obj); // &#123; "0": "a", "1": "b", "2": "c" &#125; 上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。 123Object(true) // &#123;[[PrimitiveValue]]: true&#125;Object(10) // &#123;[[PrimitiveValue]]: 10&#125;Object('abc') // &#123;0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"&#125; Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false） 注意点Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。1234var obj1 = &#123;a: &#123;b: 1&#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 Object.assign可以用来处理数组，但是会把数组视为对象。12Object.assign([1, 2, 3], [4, 5])// [4, 5, 3] 常见用途为对象添加属性通过Object.assign方法，将x属性和y属性添加到Point类的对象实例12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125; 为对象添加方法123456789101112131415Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) &#123;···&#125;;SomeClass.prototype.anotherMethod = function () &#123;···&#125;; 克隆对象123function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; 合并多个对象1const merge =(target, ...sources) =&gt; Object.assign(target, ...sources); 为属性指定默认值1234567const DEFAULTS = &#123; logLevel: 0, outputFormat: 'html'&#125;;function processContent(options) &#123; let options = Object.assign(&#123;&#125;, DEFAULTS, options);&#125; 参考es6 javascript对象方法Object.assign()Object.assign()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS实现addClass,removeClass,toggleClass]]></title>
      <url>%2Fblog%2F2016-03%2FJS%2Fnative-class-operation%2F</url>
      <content type="text"><![CDATA[jQuery操作class的方式非常强大，但是目前还有一些人不知道如何使用或者由于项目统一性的原因无法使用jquery。在此写了一个利用原生js来实现对dom元素class的操作方法 addClass: 为指定的dom元素添加样式 removeClass: 删除指定dom元素的样式 toggleClass: 如果存在(不存在)，就删除(添加)一个样式 hasClass: 判断Class是否存在 下面是各方法源码：1234567891011121314151617181920212223242526//添加Classfunction addClass(obj, cls) &#123; if (!this.hasClass(obj, cls)) obj.className += " " + cls;&#125;//删除Classfunction removeClass(obj, cls) &#123; if (hasClass(obj, cls)) &#123; var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)'); obj.className = obj.className.replace(reg, ' '); &#125;&#125;//切换Classfunction toggleClass(obj,cls)&#123; if(hasClass(obj,cls))&#123; removeClass(obj, cls); &#125; else &#123; addClass(obj, cls); &#125;&#125;//判断是否存在function hasClass(obj, cls) &#123; return obj.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML 随手笔记]]></title>
      <url>%2Fblog%2F2016-02%2FHTML%2Fhtml-notes%2F</url>
      <content type="text"><![CDATA[谷歌浏览器本地AJAX调试插件Allow-Control-Allow-Origin 谷歌插件 谷歌浏览器调试手机网页在地址栏输入:chrome://inspect 可进入手机网页调试状态注: 在地址栏输入 chrome://about 可以查看所有实用功能 Select - multiple、size12select 设置multiple属性，可以显示多列，size为显示几列&lt;select multiple class="form-control" size="3"&gt; Flash置底、背景透明12345&lt;param name="wmode" value="opaque"&gt;&lt;param name="wmode" value="transparent"&gt;注:IE7及以下版本需要设置背景透明style="background-color:transparent;" Marquee 用法123456&lt;marquee width="984" scrollamount="10" onMouseOut="this.start()" onMouseOver="this.stop()"&gt;内容&lt;/marquee&gt;注：scrollamount: 设定活动字幕的滚动速度，单位pixelsscrolldelay: 设定活动字幕滚动两次之间的延迟时间，单位millisecond（毫秒）值大了会有一步一停顿的效果 DIV变可输出框设置DIV属性 contenteditable 为 true 即可 屏蔽鼠标右键oncontextmenu=”window.event.returnValue=false” 禁止选取属性onselectstart=”return false” CSS12345div &#123; -moz-user-select:none; -webkit-user-select:none; user-select:none;&#125; 禁止复制oncopy=”return false;”oncut=”return false;” 禁止粘贴onpaste=”return false” 页面添加关键字、描述、ICON的写法123&lt;meta name="keywords" content="会员卡 "/&gt;&lt;meta name="description" content="极大扩展潜在客户群和实现企业运营的目标"/&gt;&lt;link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon"&gt; A标签相关12345678910111213去点击后的虚线框&lt;style&gt;a &#123; blur:expression(this.onFocus=this.close());&#125; /* 只支持IE，过多使用效率低 */ a &#123; blur:expression(this.onFocus=this.blur());&#125; /* 只支持IE，过多使用效率低 */ a:focus &#123; outline-style: none; &#125; /* IE不支持 */&lt;/style&gt;&lt;!--IE下可行--&gt;&lt;a href="http://www.jb51.net/css/#" hidefocus="true"&gt;链接&lt;/a&gt;Href&lt;a href="tel:86-13617630861"&gt;拨电话&lt;/a&gt;&lt;a href="sms:10086?body=102"&gt;发短信&lt;/a&gt;&lt;a href="mailto:10086@qq.com"&gt;发邮件&lt;/a&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pointer-events属性]]></title>
      <url>%2Fblog%2F2016-02%2FCSS%2Fpointer-events%2F</url>
      <content type="text"><![CDATA[功能 pointer-events 是CSS3新增属性，设置或检索在何时成为属性事件的target。pointer-events: auto | none | visiblepainted | visiblefill | visiblestroke | visible | painted | fill | stroke | all 属性值 auto: 与pointer-events属性未指定时的表现效果相同。在svg内容上与visiblepainted值相同 none: 元素永远不会成为鼠标事件的target；但是，当其子元素的pointer-events属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下鼠标事件将在捕获或冒泡阶段触发父元素的事件侦听器 其他值只能应用在SVG上 兼容性-[x] IE11+-[x] Firefox 3.6+-[x] Chrome 4.0+-[x] iOS Safari 6.0+-[x] Android Browser 2.1+ 参考CSS参考手册]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[提高Web页面性能的技巧]]></title>
      <url>%2Fblog%2F2016-02%2FHTML%2Fweb-performance%2F</url>
      <content type="text"><![CDATA[现在动辄几兆大小的页面加载量，让性能优化成了不可避免的热门话题。WEB 应用越流畅，用户体验就会越好，继而带来更多的访问量。这也就是说，我们应该反省一下那些过度美化的 CSS3 动画和多重操作的 DOM 元素是否都考虑到了在性能方面的影响。在说性能优化之前，我们有必要理清浏览器视觉绘制方面的两个术语：Repaint（重绘）: 如果某些操作影响了 DOM 元素的可见性，但又没有影响布局，那么就会发生浏览器的重绘，比如opacity，background-color,visibility 和 outline 属性。由于浏览器必须检查 DOM 中所有节点的可见性——某些图层或许会置于重绘元素的图层下面，所以重绘是一个非常繁重的逻辑。Reflow（回流）: 回流是一个更具破坏性的操作，它会让浏览器重新计算所有元素的坐标位置和尺寸大小。往往由于一个元素的变化，继而引起其子元素、父元素以及相邻元素的变化。 不管用户或者应用本身是否正在执行某些逻辑，这两种操作都会阻塞浏览器进程。极端情况下，一个 CSS 效果会降低 JavaScript 的执行速度。下面是触发回流事件的几种情境： 添加、删除和修改可见的 DOM 元素 添加、删除和修改部分 CSS 样式，比如修改元素的宽度，会影响其相邻元素的布局位置 CSS3 动画和过渡效果 使用 offsetWidth 和 offsetHeight。这种情境很诡异，读取一个元素的 offsetWidth 和 offsetHeight 属性会触发回流 用户行为，比如鼠标悬停、输入文本、调整窗口大小、修改字体样式等 浏览器的底层实现各有不同，所以渲染页面的开销也各有轻重。好在我们有一些通常规则可以进行性能优化。 使用最佳实践所建议的布局技巧虽然已经是 2015 了，但我还是要说不要使用行内联样式和 table 布局。HTML 文档下载完成后，行内样式会触发一次额外的回流事件。解析器在解析 table 布局时需要计算大量的单元格的尺寸，所以是件很重的操作。由于单元格往往是根据表头宽度确定的，所以使用 table-layout: fixed 可以缓解部分性能消耗。使用 Flexbox 布局也存在性能损失，因为在页面加载完成后，flex item 可能会发生位置和尺寸的变化。 精简 CSS 样式样式越少，回流越快，此外，尽量不要使用过于复杂的选择器。这一问题尤其突出在使用类似 Bootstrap 框架的网站上。使用Unused CSS, uCSS, grunt-uncss 和 gulp-uncss 等工具可以有效剔除无用样式。 精简 DOM 层级精简 DOM 层级，指的是减少 DOM 树的级数已经每一分支上 DOM 元素的数量，结果就是层级越少、数量越少，回流越快。此外，如果无需考虑旧版本浏览器，应该尽量剔除无意义的包裹类标签和层级。 细粒度操作 DOM 树操作 DOM 树时的粒度要尽可能细化，这有助于减弱局部 DOM 变化给整体带来的影响。 从文档流中移除复杂的动画效果应该确保使用动画的元素脱离了文档流，使用position: absolute和position: fixed属性脱离文档流的元素会被浏览器创建一个新层来存放，这些图层上的修改不会影响其他图层上的元素。 巧用隐藏方式使用display: none;隐藏的元素不会触发页面的重绘和回流事件，所以可以在这些元素隐藏期间配置样式，配置完成后再转换为可见状态。 批量更新元素单词更新所有 DOM 元素的性能要优于多次更新。下面这段代码触发了三次页面回流：1234var ele = document.getElementById('myelement');ele.width = '100px';ele.height = '200px';ele.style.margin = '10px'; 通过以下代码可以精简为一次页面回流事件，并且提高了代码的可维护性：12345.sty &#123; width: 100px; height: 200px; margin: 10px;&#125; 12var ele = document.getElementById('sty');ele.classList.add('sty'); 约束元素变化的影响这里的约束是指，尽量避免某个元素的变化引起大范围的变化。假设我们有一个 tab 选项卡的组件，选项卡内部的内容长短不一，这就导致了每个选项卡的高度不唯一。这一设计带来的问题就是每次切换选项卡时，周围的元素都要重新布局。我们可以通过一个固定高度来避免这一情况。 权衡流畅度和性能一次移动一像素的位置看起来虽然很流畅，但对于某些低性能终端会是很大的压力。一次移动四像素降低帧速虽然看起来稍有些迟钝，但性能压力降低了。这就是需要我们权衡的地方：流畅度和性能。 使用开发者工具分析页面重绘目前主流浏览器都在开发者工具中提供了监控页面重绘的功能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3 Object-fit和Object-position属性]]></title>
      <url>%2Fblog%2F2015-12%2FCSS%2Fobject-fit-position%2F</url>
      <content type="text"><![CDATA[功能介绍在CSS中，替换元素(replaced elements)，如img和video元素一直存在长宽比的控制问题，特别在在响应式设计中，如何在不同设备，不同分辨率下对这些元素的长宽进行响应。如果不想失去图像的长宽比例，让图片占据一定的空间。按照长宽比例调整和缩略图像的画面比挤压和拉伸图像是一个更优雅的解决方案。在CSS3中这种情况可以使用object-fit和object-position来处理。 object-fit属性语法object-fit: fill | contain | cover | none | scale-downobject-fit：指定了替换元素的内容应该如何使用他的宽度和高度来填充其容器，功能类似background-size适合于替换元素，比如：video、object、img、&lt;input type=”image”&gt;、svg:image、svg:video等 1234567img &#123; object-fit: fill; /*内容拉伸，填满整个容器（默认值）*/ object-fit: contain; /*内容全部都显示*/ object-fit: cover; /*容器没有留白*/ object-fit: none; /*该多大就多大*/ object-fit: scale-down; /*当内容尺寸 &gt; 壳子尺寸时，效果与contain一致；反之则与none一致*/&#125; 效果 object-position属性object-position：指定了替换元素在容器中的对齐方式，功能类似background-position适合于替换元素，比如：video、object、img、&lt;input type=”image”&gt;、svg:image、svg:video等 浏览器兼容性 IE 全家不支持，包括最新的edge android 4.4.4+ 支持，Chrome 29+ 支持 Safari 7.1+ 和 iOS 8+ 支持object-fit，不支持object-position]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3 box-reflect 倒影属性]]></title>
      <url>%2Fblog%2F2015-11%2FCSS%2Fcss3-reflect%2F</url>
      <content type="text"><![CDATA[功能说起倒影效果，在传统网页中，我们只能使用 PS 进行事先将倒影设计好，然后导入到网页中，这样不但耗费资源，也阻碍了开发的效率。而CSS3新增了 box-reflect 倒影属性设置对象倒影。 属性值none: 无倒影 定义方向above: 指定倒影在对象的上边below: 指定倒影在对象的下边left: 指定倒影在对象的左边right: 指定倒影在对象的右边 定义反射偏移的距离用长度值来定义倒影与对象之间的间隔（% | num），可以为负值 定义遮罩图像none: 无遮罩图像url: 使用绝对或相对地址指定遮罩图像linear-gradient: 使用线性渐变创建遮罩图像radial-gradient: 使用径向(放射性)渐变创建遮罩图像repeating-linear-gradient: 使用重复的线性渐变创建背遮罩像repeating-radial-gradient: 使用重复的径向(放射性)渐变创建遮罩图像 示例:1234img &#123; width:100px; -webkit-box-reflect:below 0 -webkit-linear-gradient(transparent,transparent 50%,rgba(255,255,255,.3));&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[URL编码、解码]]></title>
      <url>%2Fblog%2F2015-06%2FJS%2Furl-encoding-decoding%2F</url>
      <content type="text"><![CDATA[在JS中可以使用 escape(), encodeURL(), encodeURIComponent()，三种方法都有一些不会被编码的符号： escape()不被编码符号 @ * / +当发送页与接受页的编码格式(Charset)不一致，使用escape()转换传输中文字串就会出现乱码问题 encodeURI() | decodeURI()不被编码符号 ! @ # $&amp; * ( ) = : / ; ? + ‘ encodeURIComponent() | decodeURIComponent()不被编码符号 ! * ( ) ‘]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS em单位弹性布局]]></title>
      <url>%2Fblog%2F2015-05%2FCSS%2Fem-unit%2F</url>
      <content type="text"><![CDATA[弹性布局 浏览器的默认字体大小是16px 如果元素自身没有设置字体大小，那么元素自身上的所有属性值如“boder、width、height、padding、margin、line-height”等值，我们都可以按下面的公式来计算 1 ÷ 父元素的font-size × 需要转换的像素值 = em值 这一种千万要慢慢理解，不然很容易与第二点混了。如果元素设置了字体大小，那么字体大小的转换依旧按第二条公式计算，也就是下面的： 1 ÷ 父元素的font-size × 需要转换的像素值 = em值 元素设置了字体大小，此元素的其他属性，如“border、width、height、padding、margin、line-height”计算就需要按照下面的公式来计算：1 ÷ 元素自身的font-size × 需要转换的像素值 = em值 总之，元素设置体现继承 创建CSS样式1234567html &#123; font-size: 100%;&#125;body &#123; font-size: 1em;&#125;#wrap &#123; width: 46.25em; /*740px ÷ 16 = 46.25em */ margin: 1.5em auto; /*24px ÷ 16 = 1.5em*/ border: 0.0625em solid #ccc; /*1px ÷ 16 = 0.0625em*/&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原生JS实现ajax的get、post]]></title>
      <url>%2Fblog%2F2015-04%2FJS%2Fnative-ajax%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425var ajax = &#123; //GET get: function (url, fn) &#123; var xhr = new XMLHttpRequest(); xhr.open("GET", url, true); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200 || xhr.status == 304) &#123; fn.call(this, xhr.responseText); &#125; &#125;; xhr.send(null); &#125;, //POST post: function (url, data, fn) &#123; var xhr = new XMLHttpRequest(); xhr.open("POST", url, true); xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status == 304)) &#123; fn.call(this, xhr.responseText); &#125; &#125;; xhr.send(data); &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3 animation 相关属性]]></title>
      <url>%2Fblog%2F2015-03%2FCSS%2Fcss3-animation%2F</url>
      <content type="text"><![CDATA[功能复合属性，设置对象所应用的动画特效，如果提供多组属性值以逗号分隔 animation-name: 设置对象所应用的动画名称animation-duration: 设置对象动画的持续时间animation-timing-function: 设置对象动画的过渡类型animation-delay: 设置对象动画延迟的时间animation-iteration-count: 设置对象动画的循环次数animation-direction: 设置对象动画在循环中是否反向运动animation-fill-mode: 设置对象动画时间之外的状态animation-play-state: 设置对象动画的状态 @keyframes 关键帧提起 animation 就不得不说 @keyframes，它是指定动画名称和动画效果。@keyframes 定义的动画名称用来被 animation-name 所使用，定义动画时，简单的动画可以直接使用关键字 from 和 to，即从一种状态过渡到另一种状态。示例:1234@keyframes test-animation &#123; from &#123; opacity: 0; &#125; to &#123; opacity: 1; &#125;&#125; animation-name 属性设置对象所应用的动画名称，必须与规则 @keyframes 配合使用；对应的脚本特性为 animationName1234div &#123; animation-name: none; /* 默认值，不引用任何动画名称 */ animation-name: &lt;identifier&gt;; /* 定义一个或多个动画名称(identifier标识) */&#125; animation-duration 属性设置对象动画的持续时间，如果设置多个属性值，以逗号进行分隔；对应的脚本特性为 animationDuration 123div &#123; animation-duration: 0.3s[, 500ms]; /* 动画的持续0.3秒 */&#125; animation-timing-function 属性设置对象动画的过渡类型，如果设置多个属性值，以逗号进行分隔；对应的脚本特性为 animationTimingFunction 123456789101112div &#123; animation-timing-function: linear; /* 线性过渡 */ animation-timing-function: ease; /* 平滑过渡 */ animation-timing-function: ease-in; /* 由慢到快 */ animation-timing-function: ease-out; /* 由快到慢 */ animation-timing-function: ease-in-out; /* 由慢到快再到慢 */ animation-timing-function: step-start; /* 等同于 steps(1, start)，步进函数 */ animation-timing-function: step-end; /* 等同于 steps(1, end)，步进函数 */ animation-timing-function: cubic-bezier(0.0, 0.0, 1.0, 1.0); /* 贝塞尔曲线 */&#125; steps 步进函数 steps([, [ start | end ] ]?)：接受两个参数的步进函数。 第一个参数必须为正整数，指定函数的步数 第二个参数取值可以是start或end，指定每一步的值发生变化的时间点 第二个参数是可选的，默认值为end cubic-bezier 贝塞尔曲线 cubic-bezier(, , , ): 特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内 贝塞尔曲线-在线生成 animation-delay 属性设置对象动画的延迟时间，如果设置多个属性值，以逗号进行分隔；对应的脚本特性为 animationDelay 123div &#123; animation-delay: 0.3s[, 500ms];&#125; animation-iteration-count 属性设置对象动画的循环次数；对应的脚本特性为 animationIterationCount 1234div &#123; animation-iteration-count: infinite; /* 无限循环 */ animation-iteration-count: 10; /* 循环10次 */&#125; animation-direction 属性设置对象动画在循环中是否反向运动；对应的脚本特性为 animationDirection 123456div &#123; animation-direction: normal; /* 正常方向 */ animation-direction: reverse; /* 反方向运行 */ animation-direction: alternate; /* 动画先正常运行再反方向运行，并持续交替运行 */ animation-direction: alternate-reverse; /* 与上相反，并持续交替运行 */&#125; animation-fill-mode 属性设置对象动画时间之外的状态；对应的脚本特性为 animationFillMode 123456div &#123; animation-fill-mode: none; /* 默认值。不设置 */ animation-fill-mode: forwards; /* 设置对象状态为动画结束时的状态 */ animation-fill-mode: backwards; /* 设置对象状态为动画开始时的状态 */ animation-fill-mode: both; /* 设置对象状态为动画结束或开始的状态 */&#125; animation-play-state 属性检索或设置对象动画的状态；对应的脚本特性为 animationPlayState 1234div &#123; animation-play-state: running; /* 默认。运动 */ animation-play-state: paused; /* 暂停 */&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3 transform 相关属性]]></title>
      <url>%2Fblog%2F2015-03%2FCSS%2Fcss3-transform%2F</url>
      <content type="text"><![CDATA[transform 2D变换 translate() 位移 rotate() 旋转 scale() 缩放 skew() 斜拉 matrix() 把所有2D转换方法组合，需要六个参数 translate() 位移单位：长度，如px、em12345div &#123; transform: translate(x,y); /* 沿着X和Y轴移动元素 */ transform: translateX(n); /* 沿着X轴移动元素 */ transform: translateY(n); /* 沿着Y轴移动元素 */&#125; rotate() 旋转单位：deg、grad、rad、turn（度、梯度、弧度、圈）123div &#123; transform: rotate(-30deg); /* 负值表示逆时针 */&#125; scale() 缩放放大X，Y（宽、高）多少倍，单位数值12345div &#123; transform: scaleX(n); /* 改变元素的宽度 */ transform: scaleY(n); /* 改变元素的高度 */ transform: scale(x,y); /* 改变元素的宽度和高度 */&#125; skew() 斜拉单位：deg、grad、rad、turn（度、梯度、弧度、圈）12345div &#123; transform: skewX(angle); /* 沿着X轴斜拉 */ transform: skewY(angle); /* 沿着Y轴斜拉 */ transform: skew(x-angle,y-angle); /* 沿着X和Y轴斜拉 */&#125; matrix() 矩阵matrix() 2D平面的移动变换，2D变换矩阵为33matrix3d() 3D平面的移动变换，3D变换矩阵为44基本语法 transform: matrix(a, c, b, d, tx, ty);a, c, b, d是一个二维矩阵:tx, ty就是就是基于X和Y坐标重新定位元素。 a: 宽的缩放值 c: 沿着Y轴的倾斜转换 b: 沿着X轴的倾斜转换 d: 高的缩放值tx: 沿X轴的位移ty: 沿y轴的位移用法示例 transform 3D转换123456789101112131415div &#123; transform: translate3d(x,y,z); /* 定义3D位移转化 */ transform: translateX(x); /* 定义3D位移转化，仅使用用于X轴的值 */ transform: translateY(y); /* 定义3D位移转化，仅使用用于Y轴的值 */ transform: translateZ(z); /* 定义3D位移转化，仅使用用于Z轴的值 */ transform: scale3d(x,y,z); /* 定义3D缩放转换 */ transform: scaleX(x); /* 定义3D缩放转换，通过给定一个X轴的值 */ transform: scaleY(y); /* 定义3D缩放转换，通过给定一个Y轴的值 */ transform: scaleZ(z); /* 定义3D缩放转换，通过给定一个Z轴的值 */ transform: rotate3d(x,y,z,angle); /* 定义3D旋转 */ transform: rotateX(angle); /* 定义沿X轴的3D旋转 */ transform: rotateY(angle); /* 定义沿Y轴的3D旋转 */ transform: rotateZ(angle); /* 定义沿Z轴的3D旋转 */ transform: perspective(n); /* 定义3D转换元素的透视视图 */&#125; transform-origin 属性设置对象以某个原点进行转换，参数值为 background-position 类似 transform-style 属性指定某元素的子元素是（看起来）位于三维空间内，还是在该元素所在的平面内被扁平化 1234div &#123; transform-style: flat; /* 指定子元素位于此元素所在平面内 */ transform-style: preserve-3d; /* 指定子元素定位在三维空间内 */&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3 transition 相关属性]]></title>
      <url>%2Fblog%2F2015-03%2FCSS%2Fcss3-transition%2F</url>
      <content type="text"><![CDATA[功能复合属性，用于设置对象变换时的过渡效果，多与 transform 配合使用 transition-property: 设置对象中的参与过渡的属性 transition-duration: 设置对象过渡的持续时间 transition-timing-function: 设置对象中过渡的动画类型 transition-delay: 设置对象延迟过渡的时间 示例-缩写方式:12345div &#123; transition: border-color .5s ease-in .1s, background-color .5s ease-in .1s, color .5s ease-in .1s;&#125; transition-property 属性设置对象中的参与过渡的属性；默认值为：all，默认为所有可以进行过渡的css属性；对应的脚本特性为 transitionProperty 过渡效果的属性 属性名称 类型 background-color color background-image only gradients background-position percentage, length border-bottom-color color border-bottom-width length 更多… 其它属性这三 transition-duration、transition-timing-function、transition-delay 的取值类似于 animation相应属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS content、counter-increment、counter-reset详解]]></title>
      <url>%2Fblog%2F2015-03%2FCSS%2Fcontent%2F</url>
      <content type="text"><![CDATA[CSS 2.1 提供了在任何元素上设置递增序列的方法，而不仅仅是在LI元素上。本文主要关注以下CSS伪元素和属性： :before :after content counter-increment counter-reset content 概述content 属性与 :before 及 :after 伪元素配合使用，来插入生成内容 示例:123456789101112&lt;ul id="link"&gt; &lt;li&gt;&lt;a href="http://www.qianduan.net"&gt;前端观察&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://bestcss.net"&gt;BestCSS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="http://bbs.qianduan.net"&gt;前端社区&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;style&gt;#link a:after &#123; content:" - &lt;" attr(href) "&gt;"; color: #ff0000; font-style: italic;&#125;&lt;/style&gt; 效果： content 属性content: none | normal | &lt;string&gt; | url | open-quote | close-quote | no-open-quote | no-close-quote | attr(attribute) | counter(name[, style]) none: 不生成任何值 attr(x): 插入标签属性值 url: 使用指定的绝对或相对地址插入一个外部资源 string: 插入字符串 counter: 计数器，用于插入排序标识 counter-increment 和 counter-resetcounter 并不能单独工作，如果你只是写p:before {content: counter(subtitles, decimal);} //subtitles是自定义名字，decimal是单位 示例:12345678910111213141516171819&lt;h1&gt;第一个标题&lt;/h1&gt;&lt;h2&gt;章节&lt;/h2&gt;&lt;p&gt;文字....&lt;/p&gt;&lt;h2&gt;另一个章节&lt;/h2&gt;&lt;p&gt;文字....&lt;/p&gt;&lt;h1&gt;另一个标题&lt;/h1&gt;&lt;h2&gt;章节&lt;/h2&gt;&lt;p&gt;文字....&lt;/p&gt;&lt;h2&gt;另一个章节&lt;/h2&gt;&lt;p&gt;文字....&lt;/p&gt;&lt;style&gt;/*在每个h1的前面添加计数器，并在每一个h1后面重设h2的计数器*/h1 &#123; counter-increment:headers; counter-reset:subsections;&#125;h1:before &#123; content:counter(headers);&#125;h2 &#123; counter-increment:subsections;&#125;h2:before &#123; content:counter(headers) "." counter(subsections) ":";&#125;&lt;/style&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS 一些常用hack]]></title>
      <url>%2Fblog%2F2015-03%2FCSS%2Fhack%2F</url>
      <content type="text"><![CDATA[IE 针对样式名 Hack12345*html span &#123; color:#fc0;&#125; /* 仅 IE6 可识别 [ *html ] */*+html span &#123; color:#93C;&#125; /* 仅 IE7 可识别 [ *+html ] */html&gt;/**/body span &#123; color:#0ff;&#125; /* IE8+(含) 可识别 */html&gt;body span &#123; color:#f00;&#125; /* IE7+(含) 可识别 */*body span &#123; color:#999;&#125; /* IE7-(含) 可识别 */ IE 针对属性 Hack123456789101112131415span &#123; color:#000; /* 是浏览器都支持 */ _color:#f00; /* IE6-(含) 可识别 */ *color:#ccc; /* IE7-(含) 可识别 */ *+color:#60f; /* IE7-(含) 可识别 */ color:#c3c\0; /* IE8+(含) 可识别 */ color:#ff0\9; /* IE6+(含) 可识别 */ color:#6ff!important; /* !important 是提高属性的优先权，但IE6不支持 */&#125;/* IE9+(含) */:root span &#123; color:#ff0\9;&#125;/* IE10+(含) */@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) &#123; /*css*/ &#125; IE 条件注释123456&lt;!--[if IE 5]&gt; 仅IE5.5可见 &lt;![endif]--&gt;&lt;!--[if gt IE 5.5]&gt; 仅IE 5.5以上可见 &lt;![endif]--&gt;&lt;!--[if lt IE 5.5]&gt; 仅IE 5.5以下可见 &lt;![endif]--&gt;&lt;!--[if gte IE 5.5]&gt; IE 5.5及以上可见 &lt;![endif]--&gt;&lt;!--[if lte IE 5.5]&gt; IE 5.5及以下可见 &lt;![endif]--&gt;&lt;!--[if !IE 5.5]&gt; 非IE 5.5的IE可见 &lt;![endif]--&gt; Meta 标签12345&lt;!-- 强制浏览器按照 IE7 标准模式渲染文档 --&gt;&lt;meta http-equiv="x-ua-compatible" content="ie=7" /&gt;&lt;!-- Edge模式告诉 IE 以最高级模式渲染文档 --&gt;&lt;meta http-equiv="x-ua-compatible" content="ie=edge"&gt; JS 区分浏览器针对IE11 及 非IE浏览器，IE11下document.documentMode为11，所以html标签上会加ie11样式类；而非IE浏览器的document.documentMode为undefined，所以html标签上会加ieundefined样式 1234567if (/*@cc_on!@*/false) &#123; //IE document.documentElement.className += ' ie' + document.documentMode; //结果：ie当前版本号&#125;if (/*@cc_on!@*/true) &#123; //!IE document.documentElement.className += ' ie' + document.documentMode; //结果：ieundefined&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WAP、WML 学习手记]]></title>
      <url>%2Fblog%2F2015-03%2FHTML%2Fwap-wml%2F</url>
      <content type="text"><![CDATA[简介什么是 WAP？无线产品提出了 WAP（Wireless Application Protocol） 的理念，此标准的要点是在无线设备上展示因特网内容。WAP 标准基于因特网标准（HTML、XML 以及 TCP/IP）。它包括 WML 语言规范、WMLScript 规范以及无线电话应用接口规范（WTAI） 什么是 WML？WML 指无线标记语言。它是一种从 HTML 继承而来的标记语言，但是 WML 基于 XML，因此它较 HTML 更严格。WML 被用来创建可显示在 WAP 浏览器中的页面，用WML编写的页面被称为 DECKS。 什么是 WMLScript？WML(Wireless Markup Language) 使用 WMLScript 在客户端运行简单的代码，WMLScript 是一种轻量级的 JavaScript 语言，不过，WML 脚本并不嵌在 WML 页面中，WML页面仅仅含有对脚本 URL 的引用，WML 脚本在 WAP 浏览器运行之前，需要先在服务器上被编译为字节编码。 基础WAP 主页WML 使用标签 - 类似 HTML - 但是语法更严格且遵守 XML 1.0 标准。WML 页面的扩展名是 *.WML。 WML 标签WML 几乎都是关于文本的。会拖慢手持设备之间通信的标签不会成为 WML 标志的组成部分。表格和图像的使用被严格限制。由于 WML 是一种 XML 应用，因此其标签对大小写敏感（ 与 不同），且标签必须正确关闭。 WML Deck 和 CardWML 页面叫作 DECK（卡片组）。DECK是由一系列CARD（卡片）构造的，卡片之间通过链接彼此联系 示例12345678910&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" "http://www.wapforum.org/DTD/wml_1.1.xml"&gt;&lt;wml&gt; &lt;card id="HTML" title="HTML Tutorial"&gt; &lt;p&gt;One&lt;/p&gt; &lt;/card&gt; &lt;card id="HTML" title="HTML Tutorial"&gt; &lt;p&gt;Two&lt;/p&gt; &lt;/card&gt;&lt;/wml&gt; WML 格式化Deck 和 CardWML 页面通常称为 “deck”。每个 deck 含有一系列的 card。card 元素可包含文本、标记、链接、输入字段、task、图像等等。卡片之间通过链接彼此相互联系注：每次只显示一个 card WML 链接、图像、输入链接 - 可以制作 WML 卡片来显示 WML 的锚功能&lt;anchor&gt; 标签：总是要规定一个任务 (“go”, “prev”, 或 “refresh”)。任务定义了当用户选择此链接时要做的事情。在本例中，当用户选择 “Next page”，其任务是 “前往 test.wml”：示例:1&lt;anchor&gt;Next page&lt;go href="test.wml"/&gt;&lt;/anchor&gt; &lt;a&gt;标签：永远执行 “go” 任务，不带参数。下面的例子与那个 &lt;anchor&gt; 标签的例子起得作用是相同的：示例:1&lt;a href="test.wml"&gt;Next page&lt;/a&gt; 图像12&lt;img src="/images/stickman.wbmp" alt="stickman"/&gt;注：.wbmp 是唯一可以显示在 WAP 浏览器中的图像类型。 输入字段1&lt;input name="Sex" size="15"/&gt; 选择和选项示例:12345&lt;select multiple="true"&gt; &lt;option value="htm"&gt;HTML Tutorial&lt;/option&gt; &lt;option value="xml"&gt;XML Tutorial&lt;/option&gt; &lt;option value="wap"&gt;WAP Tutorial&lt;/option&gt;&lt;/select&gt; Fieldset可以制作 WML 卡片来显示 WML 的 fieldset 函数示例:1234&lt;fieldset title="CD Info"&gt; Title: &lt;input name="title" type="text"/&gt;&lt;br/&gt; Prize: &lt;input name="prize" type="text"/&gt;&lt;/fieldset&gt; WML 任务 - 定义了事件发生时所执行的动作Go 任务：表示 切换到一个新卡片的动作示例:1&lt;anchor&gt;Go To Test&lt;go href="test.wml"/&gt;&lt;/anchor&gt; Prev 任务：表示 后退到前面的卡片的动作示例:1&lt;anchor&gt;Go To Test&lt;prev/&gt;&lt;/anchor&gt; Refresh 任务：刷新一些指定的卡片变量示例:12345&lt;anchor&gt; Refresh this page&lt;go href="thispage.wml"/&gt; &lt;refresh&gt;&lt;setvar name="x" value="30"/&gt;&lt;/refresh&gt;&lt;/anchor&gt;表示：当用户点击该链接时，它会刷新页面，同时变量 x 的值将被设置为 30 Noop 任务&lt;noop&gt; 任务规定不做任何事（noop 指的是 “no operation”），此标签用于覆盖卡片组级别的元素。&lt;do&gt; 标签用于在用户点击屏幕上的某个单词或短语时启动一个任务示例:123&lt;do name="back" type="prev" label="Back"&gt;&lt;noop/&gt;&lt;/do&gt;此例表示：使用 &lt;do&gt; 标签向卡片添加一个 "Back" 链接，当用户点击这个 "Back" 链接时，它被带回前面的卡片。但是 &lt;noop&gt; 标签阻止了这个操作，所以当用户点击 "Back" 时，不会发生任何事情 WML 计时器、变量计时器 (Timer)可以制作 WML 卡片来使用 WML 的计时器功能。计时器的时间单位是 一秒的十分之一 [1/10 s]示例: 用 3 秒来显示一条消息，然后切换到文件 "test.wml"123456789&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN""http://www.wapforum.org/DTD/wml_1.1.xml"&gt;&lt;wml&gt; &lt;card ontimer="test.wml"&gt; &lt;timer value="30"/&gt; &lt;p&gt;Some Message&lt;/p&gt; &lt;/card&gt;&lt;/wml&gt; 变量当用户在卡片组的卡片之间切换时，我们需要在变量中存储数据。WML 变量对大小写敏感 通过 Setvar 命令规定变量当用户执行任务时（比如 go, prev 或 refresh），可使用 Setvar 元素设置带有指定值的变量示例: 创建一个名为 i 的变量，值是 50012&lt;setvar name="i" value="500"/&gt;name 和 value 属性是必需的 为输入元素规定变量可以为输入元素（比如input, select, option 等等）设置变量 将创建名为 schoolname 的变量123456&lt;card id="card1"&gt; &lt;select name="schoolname"&gt; &lt;option value="HTML"&gt;HTML Tutorial&lt;/option&gt; &lt;option value="XML"&gt;XML Tutorial&lt;/option&gt; &lt;/select&gt;&lt;/card&gt; 使用上例中创建的变量1&lt;card id="card2"&gt;&lt;p&gt;You selected: $(schoolname)&lt;/p&gt;&lt;p&gt;You selected: $(schoolname)&lt;/p&gt;&lt;/card&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SASS入门]]></title>
      <url>%2Fblog%2F2015-03%2FCSS%2Fsass-basic%2F</url>
      <content type="text"><![CDATA[在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。很自然地，有人就开始为CSS加入编程元素，这被叫做”CSS预处理器”（css preprocessor）。它的基本思想是，用一种专门的编程语言，进行网页样式设计，然后再编译成正常的CSS文件。 SASS编译环境安装SASS是Ruby语言写的，但是两者的语法没有关系。不懂Ruby，照样使用。只是必须先 安装Ruby；接着 下载RubyGems，解压文件并到此文件内打开命令窗口，运行：ruby setup.rb；然后再安装SASS，运行：gem install sass，就可以使用命令窗口编译SASS文件了。但其实现在很多前端IDE都自带CSS预处理功能，比如WebStorm等。 SASS使用SASS文件就是普通的文本文件，里面可以直接使用CSS语法。文件后缀名是 .scss，意思为 Sassy CSS。 编译文件12345//屏幕上显示.scss文件转化的css代码sass test.scss//将显示结果保存成文件sass test.scss test.css SASS提供四个编译风格的选项：123456sass --style compressed test.sass test.css//nested：嵌套缩进的css代码，它是默认值//expanded：没有缩进的、扩展的css代码//compact：简洁格式的css代码//compressed：压缩后的css代码 SASS监听某个文件或目录一旦源文件有变动，就自动生成编译后的版本12345// watch a filesass --watch input.scss:output.css// watch a directorysass --watch app/sass:public/stylesheets SASS的官方网站，提供了一个在线转换器。你可以在那里，试运行下面的各种例子。 基本语法变量sass所有变量以 $ 开头 普通变量1234$blue: #1875e7;div &#123; color: $blue;&#125; 如果变量需要 镶嵌在字符串之中，就必须需要写在 #{} 之中 1234$side: left;.rounded &#123; border-#&#123;$side&#125;-radius: 5px;&#125; 默认变量sass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要再重新声明下该变量即可123456789//sass style$baseLineHeight: 1.5 !default;$baseLineHeight: 2;body &#123; line-height: $baseLineHeight;&#125;//css stylebody &#123; line-height:2;&#125; 多值变量多值变量分为 list 类型 和 map 类型简单来说list类型有点像js中的数组，而map类型有点像js中的对象 listlist数据可通过空格，逗号或小括号分隔多个值，可用nth($var,$index)取值。关于list数据操作还有很多其他函数如length($list)，join($list1,$list2,[$separator])，append($list,$value,[$separator])等，具体可参考sass Functions（搜索List Functions即可）123456789101112131415161718192021/*定义*///一维数据$px: 5px 10px 20px 30px;//二维数据，相当于js中的二维数组$px: 5px 10px, 20px 30px;$px: (5px 10px) (20px 30px);/*使用*///sass style$linkColor: #08c #333 !default; //第一个值为默认值，第二个鼠标滑过值a&#123; color: nth($linkColor,1); &amp;:hover&#123; color: nth($linkColor,2); &#125;&#125;//css stylea&#123; color:#08c;&#125;a:hover&#123; color:#333;&#125; mapmap数据以key和value成对出现，其中value又可以是list。格式为：$map: (key1: value1, key2: value2, key3: value3);。可通过map-get($map,$key)取值。关于map数据还有很多其他函数如map-merge($map1,$map2)，map-keys($map)，map-values($map)等，具体可参考sass Functions（搜索Map Functions即可）12345678910111213141516/*定义*/$heading: (h1: 2em, h2: 1.5em, h3: 1.2em);/*使用*///sass style$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);@each $header, $size in $headings &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125;//css styleh1 &#123; font-size: 2em;&#125;h2 &#123; font-size: 1.5em;&#125;h3 &#123; font-size: 1.2em;&#125; 全局变量在变量值后面加上 !global 即为全局变量。这个目前还用不上，不过将会在sass 3.4后的版本中正式应用。目前的sass变量范围饱受诟病，所以才有了这个全局变量。目前变量机制在选择器中声明的变量会覆盖外面全局声明的变量。(这也就人们常说的sass没有局部变量) 计算功能sass允许在代码中使用表达式123456$var: 5;body &#123; margin: (14px/2); top: 50px + 100px; right: $var * 10%;&#125; 嵌套1234567891011121314151617181920//选择器嵌套div &#123; border: 1px solid green; hi &#123; color: red; &#125;&#125;//属性嵌套 【要在属性后加冒号 ：】p &#123; border: &#123; color: red; &#125;&#125;//在嵌套的代码块内，可以使用 &amp; 引用父元素a &#123; &amp;:hover &#123; color: #ffb3ff; &#125; &amp;:active &#123; color: #00ff99; &#125;&#125; @at-rootsass3.3.0中新增的功能，用来跳出选择器嵌套的。默认所有的嵌套，继承所有上级选择器，但有了这个就可以跳出所有上级选择器 普通形式1234567891011121314151617181920212223242526272829//sass style//没有跳出.parent-1 &#123; color:#f00; .child &#123; width:100px; &#125;&#125;//单个选择器跳出.parent-2 &#123; color:#f00; @at-root .child &#123; width:200px; &#125;&#125;//多个选择器跳出.parent-3 &#123; background:#f00; @at-root &#123; .child1 &#123; width:300px; &#125; .child2 &#123; width:400px; &#125; &#125;&#125; @at-root (without | with)默认@at-root只会跳出选择器嵌套，而不能跳出@media或@support，如果要跳出这两种，则需使用@at-root (without: media)，@at-root (without: support)。这个语法的关键词有四个：all（表示所有），rule（表示常规css），media（表示media），support（表示support，因为@support目前还无法广泛使用，所以在此不表）。我们默认的@at-root其实就是@at-root (without:rule)12345678910111213141516171819202122232425262728293031323334//sass style//跳出父级元素嵌套@media print &#123; .parent1&#123; color:#f00; @at-root .child1 &#123; width:200px; &#125; &#125;&#125;//跳出media嵌套，父级有效@media print &#123; .parent2&#123; color:#f00; @at-root (without: media) &#123; .child2 &#123; width:200px; &#125; &#125; &#125;&#125;//跳出media和父级@media print &#123; .parent3&#123; color:#f00; @at-root (without: all) &#123; .child3 &#123; width:200px; &#125; &#125; &#125;&#125; 注释SASS共有两种注释风格。标准的CSS注释 /* comment */ ，会保留到编译后的文件。单行注释 // comment，只保留在SASS源文件中，编译后被省略。/*! 说明 */，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。123/*! 重要注释！ */ 代码的重用继承 @extend123456789.class1 &#123; border: 1px solid #ddd;&#125;//class2要继承class1，就要使用 @extend 命令.class2 &#123; @extend .class1; font-size: 120%;&#125; Mixin无参数Mixin有点像C语言的宏（macro），是可以重用的代码块12345678910//使用@mixin命令，定义一个代码块@mixin left &#123; float: left; margin-left: 10px;&#125;//使用@include命令，调用这个mixindiv &#123; @include left;&#125; 有参数mixinmixin的强大之处，在于 可以指定参数和缺省值12345678@mixin left($pos: left, $value: 10px) &#123; float: $pos; margin-right: $value;&#125;div &#123; @include left(right, 20px);&#125; 多组值参数mixin如果一个参数有多组值，如box-shadow、transition等，那么参数则需要在变量后加三个点表示，如 $variables…123456789101112//sass style@mixin box-shadow($shadow...) &#123; box-shadow:$shadow;&#125;.box&#123; @include box-shadow(0 2px 2px rgba(0,0,0,.3),0 3px 3px rgba(0,0,0,.3),0 4px 4px rgba(0,0,0,.3));&#125;//css style.box&#123; box-shadow:0 2px 2px rgba(0,0,0,.3),0 3px 3px rgba(0,0,0,.3),0 4px 4px rgba(0,0,0,.3);&#125; 颜色函数1234lighten(#cc3, 10%); //#d6d65c -- 变浅darken(#cc3, 10%); //#a3a329 -- 加深grayscale(#cc3); //#808080 -- 灰度complement(#cc3); //#33c -- 补足 插入文件@import命令，用来插入外部文件1234@import "path/filename.scss";//如果插入的是.css文件，则等同于css的import命令。@import "foo.css"; @content123456789101112131415//sass style@mixin max-screen($res) &#123; @media only screen and (max-width: $res) &#123; @content; &#125;&#125;@include max-screen(480px) &#123; body &#123; color: red; padding:5px; &#125;&#125;//css style@media only screen and (max-width: 480px) &#123; body &#123; color: red; padding: 5px; &#125;&#125; @mixin通过@include调用后解析出来的样式是以拷贝形式存在的，而继承则是以联合声明的方式存在的，所以从3.2.0版本以后，建议传递参数的用@mixin，而非传递参数类的使用下面的继承% 占位选择器%【占位选择器以 % 标识定义，通过 @extend 调用】这种选择器的优势在于：如果不调用则不会有任何多余的css文件注：在@media中暂时不能@extend @media外的代码片段，以后将会可以123456789101112131415%ir&#123; color: transparent; text-shadow: none; background-color: transparent; border: 0;&#125;#header&#123; h1&#123; @extend %ir; width:300px; &#125;&#125;.ir&#123; @extend %ir;&#125; 高级语法条件语句@if @else12345@if lightness($color) &gt; 30% &#123; //lightness -- 亮度 background-color: #000;&#125; @else &#123; background-color: #fff;&#125; 三目判断类似Javascript的 条件表达式语法为：if($condition, $if_true, $if_false)注：三目判断 if 前没有@1234567//sass styleh1&#123; border:if(1 &gt; 2, 10px, -10px) solid #fff;&#125;//css styleh1 &#123; border: -10px solid #fff; &#125; 循环语句@for循环for循环有两种形式：@for $var from 1 through 10 //循环10次，包含10@for $var from 1 to 10 //循环9次，不含1012345@for $i from 1 to 10 &#123; .border-#&#123;$i&#125; &#123; border: #&#123;$i&#125;px solid blue; &#125;&#125; @while循环12345$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125; @each命令，作用与@for类似12345678910111213141516171819202122232425语法为：@each $var in &amp;lt;list or map&amp;gt;//普通遍历@each $member in a, b, c, d &#123; .#&#123;$member&#125; &#123; background-image: url("/image/#&#123;$member&#125;.jpg"); &#125;&#125;//遍历list$animal-data: (puma, black, default),(sea-slug, blue, pointer),(egret, white, move);@each $animal, $color, $cursor in $animal-data &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); border: 2px solid $color; cursor: $cursor; &#125;&#125;//遍历map$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);@each $header, $size in $headings &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125; 自定义函数1234567@function double($n) &#123; @return $n * 2;&#125;#sidebar &#123; width: double(5px);&#125; 参考SASS用法指南SASS语法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3 appearance 属性]]></title>
      <url>%2Fblog%2F2015-02%2FCSS%2Fcss3-appearance%2F</url>
      <content type="text"><![CDATA[功能改变按钮和其他控件的外观，使其类似于原生控件；目前使用此属性，还需要添加各自浏览器的私有前缀[webkit、moz] 语法appearance: normal | icon | window | button | menu | field | 等 属性值 值 描述 normal 将元素呈现为常规元素 icon 将元素呈现为图标（小图片） window 将元素呈现为视口 button 将元素呈现为按钮 menu 将元素呈现为一套供用户选择的选项 field 将元素呈现为输入字段 更多…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3 filter 详解]]></title>
      <url>%2Fblog%2F2015-02%2FCSS%2Fcss3-filter%2F</url>
      <content type="text"><![CDATA[功能CSS滤镜属性，可以在元素呈现之前为元素的渲染提供一些效果，如模糊、颜色转移之类的；滤镜常用于调整图像、背景、边框的渲染 属性值目前使用此属性，还需要添加各自浏览器的私有前缀[webkit、ms、moz]，此处示例代码用的是webkit前缀 属性 解释 值 示例 grayscale 灰度 值为0-1之间的小数 -webkit-filter:grayscale(1); sepia 褐色 值为0-1之间的小数 -webkit-filter:sepia(1); saturate 饱和度 值为num -webkit-filter:saturate(0.5); hue-rotate 色相旋转 值为angle -webkit-filter:hue-rotate(90deg); invert 反色 值为0-1之间的小数 -webkit-filter:invert(1); opacity 透明度 值为0-1之间的小数 -webkit-filter:opacity(.2); brightness 亮度 值为0-1之间的小数 -webkit-filter:brightness(.5); contrast 对比度 值为num -webkit-filter:contrast(2); blur 模糊 值为length -webkit-filter:blur(3px); drop-shadow 阴影 -webkit-filter:drop-shadow(5px 5px 5px #ccc); 效果预览]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CheakBox 开关效果]]></title>
      <url>%2Fblog%2F2015-02%2FCSS%2Fcheakbox-style%2F</url>
      <content type="text"><![CDATA[由于CSS代码过长，此处只展示效果，有需要源代码的可以留言]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS 书写规范与顺序]]></title>
      <url>%2Fblog%2F2015-01%2FCSS%2Fstandard%2F</url>
      <content type="text"><![CDATA[CSS书写顺序CSS选择器中的属性顺序： 显示属性 -&gt; 自身属性 -&gt; 文本属性 -&gt; 背景 -&gt; 其它 1、位置属性(position, z-index, display, float, …) 2、大小(width, height, padding, margin) 3、文字系列(font, line-height, letter-spacing, …) 4、背景(background, border, …) 5、其他(animation, transition, …) 原因：这个顺序是项目开发的代码标准，符合浏览器的渲染顺序，最终达到提高执行效率目的 CSS书写规范 使用CSS缩写属性，比如padding,margin,font等 去掉小数点前的“0” 16进制颜色代码缩写的就缩写]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[A标签的一些属性]]></title>
      <url>%2Fblog%2F2015-01%2FHTML%2Fa-attr%2F</url>
      <content type="text"><![CDATA[去虚线框12345678&lt;style&gt;a &#123; blur:expression(this.onFocus=this.close());&#125; /* 只支持IE，过多使用效率低 */ a &#123; blur:expression(this.onFocus=this.blur());&#125; /* 只支持IE，过多使用效率低 */ a:focus &#123; outline-style: none; &#125; /* IE不支持 */&lt;/style&gt;&lt;!--IE下可行--&gt;&lt;a href="http://www.jb51.net/css/#" hidefocus="true"&gt;链接&lt;/a&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用的 Meta 标签]]></title>
      <url>%2Fblog%2F2015-01%2FHTML%2Fmeta-tag%2F</url>
      <content type="text"><![CDATA[12345678视图窗口，移动端特属的标签&lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui"&gt;width - viewport的宽度height - viewport的高度initial-scale - 初始的缩放比例minimum-scale - 允许用户缩放到的最小比例maximum-scale - 允许用户缩放到的最大比例user-scalable - 用户是否可以手动缩放 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889是否启动webapp功能，会删除默认的苹果工具栏和菜单栏&lt;meta name="apple-mobile-web-app-capable" content="yes"&gt;当启动webapp功能时，显示手机信号、时间、电池的顶部导航栏的颜色，默认值为default（白色）&lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt;告诉iphone的safari浏览器，此网站对应app是什么，然后在页面上面显示一个app下载信息&lt;meta name="apple-itunes-app" content="app-id=425349261"&gt;忽略页面中的数字识别为电话号码&lt;meta name="format-detection" content="telephone=no"&gt;同样还有一个email识别&lt;meta name="format-detection" content="email=no"&gt;当然两者可以写在一起（电话号码，email）&lt;meta name="format-detection" content="telephone=no, email=no"&gt;IOS中Safari设置保存到桌面图标&lt;link rel="apple-touch-icon" href="custom_icon.png"&gt;这是IOS中Safari特有的meta，是在你保存某个页面到桌面的时候使用这张图作为桌面图标。所以尺寸和iphone上的一致，是57*57px针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓&lt;meta name="HandheldFriendly" content="true"&gt;避免IE使用兼容模式&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;windows phone 点击无高光&lt;meta name="msapplication-tap-highlight" content="no"&gt;微软的老式浏览器&lt;meta name="MobileOptimized" content="320"&gt;UC强制竖屏&lt;meta name="screen-orientation" content="portrait"&gt;UC强制全屏&lt;meta name="full-screen" content="yes"&gt;QQ强制竖屏&lt;meta name="x5-orientation" content="portrait"&gt;QQ强制竖屏&lt;meta name="x5-orientation" content="portrait"&gt;QQ强制全屏&lt;meta name="x5-fullscreen" content="true"&gt;QQ应用模式&lt;meta name="x5-page-mode" content="app"&gt;启用360浏览器的极速模式(webkit)&lt;meta name="renderer" content="webkit"&gt;下面三个是清除缓存 微信浏览器缓存严重又无刷新；这个方法调试的时候很方便&lt;meta http-equiv="Pragma" content="no-cache"&gt;&lt;meta http-equiv="Cache-Control" content="no-cache"&gt;&lt;meta http-equiv="Expires" content="0"&gt;允许HTTPS 和 HTTP 混合加载&lt;meta http-equiv="content-security-policy" content="block-all-mixed-content"&gt;IE9 模式支持全范围的既定行业标准&lt;meta http-equiv="X-UA-Compatible" content="IE=9"&gt;IE8 模式强制浏览器按照 IE8 标准模式渲染文档&lt;meta http-equiv="X-UA-Compatible" content="IE=8"&gt;IE7 模式强制浏览器按照 IE7 标准模式渲染文档&lt;meta http-equiv="X-UA-Compatible" content="IE=7"&gt;Emulate IE 模式告诉 IE 使用指令来决定如果渲染文档。标准模式下以 IE9/8/7 渲染，怪癖模式下以 IE5 渲染&lt;meta http-equiv="X-UA-Compatible" content="IE=EmulateIE9"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=EmulateIE8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7"&gt;Edge 模式告诉 IE 以最高级模式渲染文档&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;使用以下代码强制 IE 使用 Chrome Frame 渲染，如果检测到 IE 并未安装 Google Frame，则弹出对话框提示安装&lt;meta http-equiv="X-UA-Compatible" content="chrome=1"&gt;&lt;script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"&gt;&lt;/script&gt;&lt;script&gt;CFInstall.check();&lt;/script&gt;最佳的兼容模式方案，结合考虑以上两种：&lt;meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Slider焦点图切换插件]]></title>
      <url>%2Fblog%2F2015-01%2FjQuery%2FPC-Slider%2F</url>
      <content type="text"><![CDATA[关于Slider Slider是基本jQuery的Banner(焦点图)切换插件，于2015年一次项目需要开发的，后经过多次优化和扩展。 可设置效果 是否显示左右按钮、是否始终显示左右按钮，是否显示默认箭头 是否显示Dot，Dot背景条，Dot序号 Dot是否支持事件，以及事件类型 首次显示等几张banner 是否自动切换，自动切换间隔时间 3种切换效果[fade, slide, rect]，默认fade，及效果过渡时间 rect效果支持 X|Y 轴的切换，rect效果是否循环切换 rect效果是否允许快速切换 切换完成后的方法回调 其它样式（如宽度，位置等），可通过CSS直接设置 源文件下载本地 JS CSS LESS （提供LESS预处理语言版本，其它CSS预处理需自行转换） Coding.net Slider 引用方法12345678910111213&lt;!--在head标签内添加:--&gt;&lt;link rel="stylesheet" href="css/slider.min.css"&gt;&lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="js/slider.min.js"&gt;&lt;/script&gt;&lt;!--在body标签内添加:--&gt;&lt;div class="fs-wrap"&gt; &lt;div class="fs-img"&gt; &lt;a style="background-image:url(images/1.jpg)"&gt;&lt;/a&gt; &lt;a style="background-image:url(images/2.jpg)"&gt;&lt;/a&gt; &lt;a style="background-image:url(images/3.jpg)"&gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 调用方法123456789101112131415161718192021$(".fs-wrap").CSlider(&#123; effect: "fade", //切换效果 [fade, slide, rect] axis: "x", //rect效果移动轴 [x, y] emit: "mouseenter", //触发事件 [mouseenter, click, dbclick] isAuto: true, //是否自动切换Silde isDot: true, //是否有Dot isDotBg: false, //Dot是否显示背景条 isDotNum: false, //Dot是否显示序号 isDotEmit: true, //Dot是否支持事件 isPN: true, //是否显示左右Button isPNOpen: true, //是否始终显示左右Button（false:即鼠标移入Slider才显示） isPNTxt: true, //左右Button是否有箭头 isQuick: true, //是否允许快速切换（即动画未完成时是否允许下一个动画切换） isLoop: true, //是否允许循环切换 speed: 5000, //Silde切换时间 U.ms effectTime: 500, //效果切换时间 U.ms onset: 0, //开始图片显示 callback: function () &#123; //切换完成后回调 console.log(this); &#125;&#125;); 参数说明 时间参数单位为毫秒 字符参数将强制小写 数值参数为正整数 isXxx 型参数都为布尔型[true, false] effect 参数非[fade, slide, rect]，将强制设置为 fade emit 参数非[mouseenter, click, dbclick]，将强制设置为 mouseenter effectTime 参数非正整数时，将强制设置为 500 isAuto 为true时，speed 参数非正整数时，将强制设置为 5000 isAuto 为true时，effectTime 参数值必须小于 speed，否则将强制设置为 speed 的0.5倍 isPN 为true时，如果图片数量为 1，将强制设置为 false axis 参数非[x, y]，将强制设置为 x 运行效果 更新日志 2.2.1 优化回调方法逻辑，以及各参数间的设置逻辑 [2017-02-09] 2.2.0 新增rect切换模式，支持 X|Y 轴的切换 [2017-02-08] 2.1.2 添加isDotEmit:Dot是否支持事件，isQuick:是否允许快速切换 [2017-02-07] 2.1.1 添加isPNOpen参数，设置左右Button是否一直显示 [2017-01-09] 2.1.0 优化了参数名称及已知BUG [2017-01-07] 2.0.0 新增两种切换模式，删除JS里设置CSS [2017-01-04] …… 1.0.0 项目创建 [2015-01-06]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[泽元CMS标签]]></title>
      <url>%2Fblog%2F2015-01%2FHTML%2FZY-CMS-tag%2F</url>
      <content type="text"><![CDATA[新闻列表1&lt;cms:list item="Article" name="今日聚焦/新闻" count="1" begin="0" type="Recent"&gt;&lt;/cms:list&gt; 属性 描述 ${Article.Title} 新闻标题 ${Article.SubTitle} 新闻副标题 ${Article.ShortTitle} 新闻短标题 ${Article.Content} 新闻内容 ${Article.Author} 新闻作者 ${Article.Link} 新闻链接地址 ${Article.Summary} 新闻摘要 ${Article.PublishDate (Format=yyyy-MM-dd)} 新闻日期 ${Article.NewsThumbnail} 新闻缩短图(自定义的) ${Article.FocusUrl} 焦点图链接地址(自定义的) 其中：charWidth 是设置文字数量的，例：${Article.Title|charWidth=24} 判断形式1234567&lt;cms:list item="Article" name="今日聚焦/新闻" count="5" begin="0" type="Recent"&gt; &lt;% if(i==0)&#123; %&gt; &lt;li&gt;&lt;a href="$&#123;article.Link&#125;"&gt;$&#123;article.title|charwidth=18&#125;&lt;/a&gt;&lt;/li&gt; &lt;% &#125; else &#123; %&gt; &lt;li&gt;&lt;a href="$&#123;article.Link&#125;"&gt;$&#123;article.title|charwidth=24&#125;&lt;/a&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/cms:list&gt; 获取栏目链接12&lt;cms:link type='catalog' name='牛博士宽频' /&gt;&lt;!--注：获取链接时，用栏目ID无法获取成功--&gt; 返回首页1&lt;a href=".."&gt;返回首页&lt;/a&gt; 日期、时间${Article.PublishDate|Format=yyyy-MM-dd}G 年代标志符(Text) ADy 年(Number) 1996M 月(Text &amp; Number) July &amp; 07d 日(Number) 10h 时在上午或下午(1~12)(Number) 12H 时在一天中(0~23)(Number) 0m 分(Number) 30]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS 文字相关属性]]></title>
      <url>%2Fblog%2F2015-01%2FCSS%2Ftext-attributes%2F</url>
      <content type="text"><![CDATA[字体风格font-style: normal | italic | oblique设置文本字体样式 12345p &#123; font-style: normal; /*正常*/ font-style: italic; /*斜体*/ font-style: oblique; /*使文字倾斜，而不是去选取字体中的斜体字*/&#125; 字体参数font-variant: normal | small-caps将正常文字缩小一半尺寸后大写显示 123p &#123; font-variant: small-caps;&#125; 文字变形text-transform: none | capitalize | uppercase | lowercase | full-widt设置字母大小写 1234567p &#123; text-transform: none; /*无转换*/ text-transform: capitalize; /*将每个单词的第一个字母转换成大写*/ text-transform: uppercase; /*将每个单词转换成大写*/ text-transform: lowercase; /*将每个单词转换成小写*/ text-transform: full-width; /*将所有字符转换成fullwidth形式*/&#125; 文字修饰text-decoration: none | underline | overline | line-through | blink文本的装饰 1234567p &#123; text-decoration: none; /*无*/ text-decoration: underline; /*文字下划线*/ text-decoration: overline; /*文字上划线*/ text-decoration: line-through; /*给文字划出删除线*/ text-decoration: blink; /*赋予文字闪烁的效果*/&#125; 文字对齐text-align: left | right | center | start | end | justify | match-parent | justify-all文字水平对齐方式 1234567891011p &#123; text-align: left; /*左对齐*/ text-align: center; /*居中对齐*/ text-align: right; /*右对齐*/ /*以下是CSS3新增属性*/ text-align: justify; /*两端对齐，但对强制打断的行及最后一行不做处理*/ text-align: justify-all; /*同上，但最后一行两端对齐*/ text-align: match-parent; /*和inherit表现一致；[待补充]*/ text-align: start; /*开始边界对齐*/ text-align: end; /*结束边界对齐*/&#125; 文本大小text-size-adjust: auto | none | &lt;percentage&gt;设置移动端页面中对象文本的大小调整，目前要使用需要加各浏览器的私有前缀 -webkit-, -moz-, -o-, -ms- 属性值 auto: 文本大小根据设备尺寸进行调整 none: 文本大小不会根据设备尺寸进行调整 : 用百分比来指定文本大小在设备尺寸不同的情况下如何调整 说明 当样式表里font-size &lt; 12px时，移动端浏览器里字体显示仍为12px，这时可以用html { -webkit-text-size-adjust:none;} -webkit-text-size-adjust 放在body上会导致页面缩放失效 body会继承定义在html的样式 用-webkit-text-size-adjust不要定义成可继承的或全局的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3 混合模式]]></title>
      <url>%2Fblog%2F2015-01%2FCSS%2Fbg-mode%2F</url>
      <content type="text"><![CDATA[关于混合模式熟悉PS的人都应该知道混合模式，SVG以及Canvas中也有混合模式，本质上概念都是一样的。 mix-blend-mode 属性作用mix-blend-mode 字面意思就是混合模式。该CSS属性作用是让元素内容和这个元素的背景以及下面的元素发生“混合” 属性值12345678910111213141516171819202122div &#123; mix-blend-mode: normal; /*正常*/ mix-blend-mode: multiply; /*正片叠底*/ mix-blend-mode: screen; /*滤色*/ mix-blend-mode: overlay; /*叠加*/ mix-blend-mode: darken; /*变暗*/ mix-blend-mode: lighten; /*变亮*/ mix-blend-mode: color-dodge; /*颜色减淡*/ mix-blend-mode: color-burn; /*颜色加深*/ mix-blend-mode: hard-light; /*强光*/ mix-blend-mode: soft-light; /*柔光*/ mix-blend-mode: difference; /*差值*/ mix-blend-mode: exclusion; /*排除*/ mix-blend-mode: hue; /*色相*/ mix-blend-mode: saturation; /*饱和度*/ mix-blend-mode: color; /*颜色*/ mix-blend-mode: luminosity; /*亮度*/ mix-blend-mode: initial; /*初始*/ mix-blend-mode: inherit; /*继承*/ mix-blend-mode: unset; /*复原*/&#125; background-blend-mode 属性background-blend-mode 这个要更好理解一点，背景的混合模式。可以是背景图片间的混合，也可以是背景图片和背景色的混合。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端字体引入思考]]></title>
      <url>%2Fblog%2F2015-01%2FCSS%2FMobile-font-thinking%2F</url>
      <content type="text"><![CDATA[CSS 引入字体的方法12345678@font-face &#123; font-family: 'MicrosoftYaHei'; src: url('MicrosoftYaHei.eot'); /* IE9 Compat Modes */ src: url('MicrosoftYaHei.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('MicrosoftYaHei.woff') format('woff'), /* Modern Browsers */ url('MicrosoftYaHei.ttf') format('truetype'), /* Safari, Android, iOS */ url('MicrosoftYaHei.svg#MicrosoftYaHei') format('svg'); /* Legacy iOS */&#125; 移动端到底有必要引入字体吗？引入字体带来了影响，一来消耗用户的流量，二来对页面的打开速度造成了延迟。总感觉不好，为了说服产品经理，找了三大手机系统的字体资料： IOS 系统字体 默认中文字体是STHeiti(苹果黑体) 默认英文字体是Helvetica 默认数字字体是HelveticaNeue 无微软雅黑字体 Android 系统字体 默认中文字体是Droidsansfallback 默认英文和数字字体是Droid Sans 无微软雅黑字体 WindowPhone 系统字体 默认中文字体是Dengxian(方正等线体) 默认英文和数字字体是Segoe 无微软雅黑字体 结论 那么，使用系统默认的字体所达到的视觉效果跟使用微软雅黑字体没有明显的差别，权衡利弊，最终说服了产品经理放弃使用微软雅黑的想法。 各个手机系统有自己的默认字体，且都不支持微软雅黑如无特殊需求，手机端无需定义中文字体，使用系统默认英文字体和数字字体可使用 Helvetica ，三种系统都支持。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS @media 查询]]></title>
      <url>%2Fblog%2F2015-01%2FCSS%2Fmedia-query%2F</url>
      <content type="text"><![CDATA[作用@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 语法1@media mediatype and|not|only (media feature) &#123; &#125; 可以针对不同的媒体使用不同CSS文件:1&lt;link media="mediatype and|not|only (media feature)" href="sheet.css" rel="stylesheet"&gt; 类型 值 描述 all 用于所有设备 print 用于打印机和打印预览 screen 用于电脑屏幕，平板电脑，智能手机等 speech 应用于屏幕阅读器等发声设备 还有有些废弃类型如：aural、braille、embossed、handheld、projection、tty、tv 功能 值 描述 width 定义输出设备中的页面可见区域宽度 height 定义输出设备中的页面可见区域高度 max-width 定义输出设备中的页面最大可见区域宽度 max-height 定义输出设备中的页面最大可见区域高度 min-width 定义输出设备中的页面最小可见区域宽度 min-height 定义输出设备中的页面最小可见区域高度 aspect-ratio 定义输出设备中的页面可见区域宽度与高度的比率 color 定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于0 color-index 定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0 device-aspect-ratio 定义输出设备的屏幕可见宽度与高度的比率 device-height 定义输出设备的屏幕可见高度 device-width 定义输出设备的屏幕可见宽度 grid 用来查询输出设备是否使用栅格或点阵 max-aspect-ratio 定义输出设备的屏幕可见宽度与高度的最大比率 max-color 定义输出设备每一组彩色原件的最大个数 max-color-index 定义在输出设备的彩色查询表中的最大条目数 max-device-aspect-ratio 定义输出设备的屏幕可见宽度与高度的最大比率 max-device-height 定义输出设备的屏幕可见的最大高度 max-device-width 定义输出设备的屏幕最大可见宽度 max-monochrome 定义在一个单色框架缓冲区中每像素包含的最大单色原件个数 max-resolution 定义设备的最大分辨率 min-aspect-ratio 定义输出设备中的页面可见区域宽度与高度的最小比率 min-color 定义输出设备每一组彩色原件的最小个数 min-color-index 定义在输出设备的彩色查询表中的最小条目数 min-device-aspect-ratio 定义输出设备的屏幕可见宽度与高度的最小比率 min-device-width 定义输出设备的屏幕最小可见宽度 min-device-height 定义输出设备的屏幕的最小可见高度 min-monochrome 定义在一个单色框架缓冲区中每像素包含的最小单色原件个数 min-resolution 定义设备的最小分辨率 monochrome 定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0 orientation 定义输出设备中的页面可见区域高度是否大于或等于宽度 resolution 定义设备的分辨率。如：96dpi, 300dpi, 118dpcm scan 定义电视类设备的扫描工序 示例1234567891011&lt;!--当屏幕可视区宽度最大值是600PX,应用此CSS--&gt;&lt;link rel="stylesheet" media="screen and (max-width:600px)" href="xxx.css"&gt;&lt;!--当屏幕可视区宽度在600PX-900PX之间时,应用此CSS--&gt;&lt;link rel="stylesheet" media="screen and (min-width:600px) and (max-width:900px)" href="xxx.css"&gt;&lt;!--当手机最大屏幕可视区宽度在480PX,应用此CSS--&gt;&lt;link rel="stylesheet" media="screen and (max-device-width:480px)" href="xxx.css"&gt;&lt;!--当移动设备的方向发生变化时,纵向（portrait）/ 横向（landscape）--&gt;&lt;link rel="stylesheet" media="all and (orientation:portrait/landscape)" href="xxx.css"&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用小样式集合]]></title>
      <url>%2Fblog%2F2015-01%2FCSS%2Ffavorite-css%2F</url>
      <content type="text"><![CDATA[文字超长度加点1234/* 多行（只支持webkit浏览器）*/.p1 &#123; display:-webkit-box; -webkit-box-orient:vertical; margin-bottom:.05rem; -webkit-line-clamp:2; overflow:hidden; text-overflow:ellipsis; &#125;/* 单行 */.p2 &#123; width:150px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;&#125; CSS3 Loading 效果需要一张png图片12345.loading &#123; background-position:0 100%; transform:rotate(0deg); -webkit-transform:rotate(0deg); -webkit-transition-duration:0; -webkit-animation-name:loading; -webkit-animation-duration:1.5s; -webkit-animation-iteration-count:infinite; -webkit-animation-timing-function:linear;&#125;@-webkit-keyframes loading &#123; from &#123; -webkit-transform:rotate(0deg);&#125; to &#123; -webkit-transform:rotate(360deg);&#125;&#125; 设置 placeholder 属性提示文字颜色1234::-webkit-input-placeholder &#123; color:#ccc;&#125;::-moz-placeholder &#123; color:#ccc;&#125;:-moz-placeholder &#123; color:#ccc;&#125;:-ms-input-placeholder &#123; color:#ccc;&#125; 背景层透明（兼容IE）1.opa &#123; filter:alpha(opacity=80); opacity:0.8; &#125; 文本换行123p &#123; white-space:nowrap;&#125; /* 强制不换行 */p &#123; word-wrap:break-word; word-break:normal;&#125; /* 自动换行 */p &#123; word-break:break-all;&#125; /* 强制英文单词断行 */ 最优的浮动清除方案123.clear:after &#123; visibility:hidden; display:block; font-size:0; content:""; clear:both; height:0;&#125;* html .clear &#123;zoom:1;&#125;*:first-child + html .clear &#123;zoom:1;&#125; DIV内容垂直居中1box-middle &#123; display:-webkit-box; display:-ms-flexbox; display:-webkit-flex; display:flex; -webkit-box-pack:center; -ms-flex-pack:center; -webkit-justify-content:center; justify-content:center; -webkit-box-align:center; -ms-flex-align:center; -webkit-align-items:center; align-items:center;&#125; 弹框浏览器窗口居中显示12345678910111213141516171819.message &#123; position:fixed!important; position:absolute;/*IE6*/ z-index:9; left:50%; top:50%; width:400px; height:300px; background:#ddd; overflow:hidden; margin-top:0px; margin-left:-200px!important; /*宽的1/2 */ margin-top:-150px!important; /*高的1/2*/ _top:expression(eval(document.compatMode &amp;&amp; document.compatMode=='CSS1Compat') ? documentElement.scrollTop + (document.documentElement.clientHeight-this.offsetHeight)/2 :/*IE6*/ document.body.scrollTop + (document.body.clientHeight - this.clientHeight)/2);/*IE5 IE5.5*/&#125; 取消Select默认样式12select &#123; -webkit-appearance: none; -moz-appearance: none; appearance:none;&#125;select::-ms-expand &#123; background:none; border:none; color:rgba(255,255,255,0);&#125; /*IE 10+*/ 向上箭头（非45度角）1&lt;span class="icon-arwTop"&gt;&lt;i class="i1"&gt;&lt;/i&gt;&lt;i class="i2"&gt;&lt;/i&gt;&lt;/span&gt; 1234.icon-arwTop &#123; position:absolute; left:50%; bottom:10px; display:block; width:66px; height:30px; margin-left:-33px; &#125;.icon-arwTop i &#123; position:absolute; top:0; display:block; width:40px; height:12px; border-radius:6px; background:rgba(220, 220, 220, 0.95); &#125;.icon-arwTop i.i1 &#123; left:0; -webkit-transform:rotate(-20deg); box-shadow:-1px 0 0 rgba(111, 111, 111, 0.5); &#125;.icon-arwTop i.i2 &#123; right:0; -webkit-transform:rotate(20deg); box-shadow:1px 0 0 rgba(111, 111, 111, 0.5); &#125; 向右箭头1.icon-arwR:after &#123; position:absolute; top:43%; right:12px; content:""; width:13px; height:13px; border:2px solid #999; border-width:2px 2px 0 0; -webkit-transform:rotate(45deg); -moz-transform:rotate(45deg); -ms-transform:rotate(45deg); transform:rotate(45deg); &#125; 背景渐变1.bg &#123; background-image:-webkit-linear-gradient(#f9f9f9, #eaeaea); background-image:-moz-linear-gradient(#f9f9f9, #eaeaea); background-image:linear-gradient(#f9f9f9, #eaeaea); &#125; 高光移动1&lt;div class="t2"&gt;&lt;img src="images/1.jpg"&gt;&lt;i class="light"&gt;&lt;/i&gt;&lt;/div&gt; 123.t2 &#123; position:relative; width:206px; height:147px; &#125;.t2 .light &#123; position:absolute; left:-90px; top:0; width:50%; height:100%; background-image:-webkit-linear-gradient(0deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0)); background-color:red; -webkit-transform:skewx(-25deg); -webkit-transition:0s; &#125;.t2:hover .light &#123; left:160px; -webkit-transition:0.5s; &#125; 固定头部条（兼容IE）1234.topBar &#123; position:fixed; z-index:101; overflow:hidden; width:100%; height:44px; left:0; top:0; background:url(images/topBarMC.png) repeat-x;&#125;* html,* html body &#123; _background:url(about:blank) fixed;&#125;* html .topBar &#123; _position:absolute; _bottom:auto; _top:expression(eval(document.documentElement.scrollTop));&#125; 桃心1&lt;div class="heart"&gt;&lt;/div&gt; 12345.heart &#123; position:relative; width:200px; height:200px; background:#F01; -webkit-transform:rotate(45deg); -moz-transform:rotate(45deg); -o-transform:rotate(45deg); -ms-transform:rotate(45deg); transform:rotate(45deg); &#125;.heart:after,.heart:before &#123; content:""; position:absolute; width:100%; height:100%; border-radius:100%; background:inherit; &#125;.heart:after &#123; left:-50%; top:0; &#125;.heart:before &#123; right:0; top:-50%; &#125; 小三角1234.s_m_sub_cur &#123; position:relative; &#125;.s_m_sub_cur:after &#123; position:absolute; right:15px; top:11px; content:""; width:0; height:0; line-height:0; font-size:0; overflow:hidden; border-color:transparent transparent transparent #DDD; border-style:solid; border-width:7px; &#125;/*兼容IE6的小三角*/.s_m_sub_cur &#123; display:inline-block; width:0; height:0; margin-top:-6px; border-style:solid; border-color:transparent; _border-color:#FFF; border-right-color:#F90; border-width:6px 6px 6px 0; overflow:hidden; &#125; input文本框中禁用中文输入法12345678input, textarea &#123; ime-mode:disabled; &#125;::-ms-clear,::-ms-reveal &#123; display:none; &#125;/* 注：ime-mode 为非标准属性，该属性只有IE和Firefox支持::-ms-clear 是文本清除按钮，也就是input右方的叉叉::-ms-reveal 是密码查看按钮，也就密码框右边的小眼睛*/ mobile Web 自适应的CSS初始设置12345678910111213html &#123; font-size:87.5px;&#125;@media (min-width:300px) &#123; html &#123; font-size:100px;&#125;&#125;@media (min-width:360px) &#123; html &#123; font-size:112.5px;&#125;&#125;@media (min-width:400px) &#123; html &#123; font-size:125px;&#125;&#125;body, html &#123; min-height:100%; min-width:320px;&#125;body &#123; -webkit-text-size-adjust:none; font:normal 14px/18px arial; color:#333;&#125;/*html设置的值是控制外层元素的宽高，body设置的值控制子元素的宽高*/ -ms-interpolation-mode 属性1234/*IE7中自带的-ms-interpolation-mode属性可以解决缩放失真问题*/.img01 &#123; -ms-interpolation-mode:Nearest-Neighbor;&#125;.img02 &#123; -ms-interpolation-mode:normal;&#125;.img03 &#123; -ms-interpolation-mode:bicubic;&#125; 选择器-文字123p:first-letter &#123; &#125; /*选择每个 &lt;p&gt; 元素的首字母。*/p:first-line &#123; &#125; /*选择每个 &lt;p&gt; 元素的首行。*/p:first-child &#123; &#125; /*选择属于父元素的第一个子元素的每个 &lt;p&gt; 元素*/ 折角效果12.note &#123; position:relative; background:linear-gradient(-150deg, transparent 1.5em, #fff 0);&#125;.note::before &#123; position:absolute; top:0; right:0; content:''; width:3em; height:1.73em; background:linear-gradient(to left bottom, transparent 50%, rgba(0, 0, 0, .4) 0) 100% 0 no-repeat;&#125; 文字加波浪符需要根据字体大小来调整背景图1234567a &#123;background: -webkit-linear-gradient(135deg, transparent 40%, red 0, red 60%, transparent 0) 0 1em, -webkit-linear-gradient(45deg, transparent 40%, red 0, red 60%, transparent 0) 0.1em 1em;background: linear-gradient(-45deg, transparent 40%, red 0, red 60%, transparent 0) 0 1em, linear-gradient(45deg, transparent 40%, red 0, red 60%, transparent 0) 0.1em 1em;background-repeat: repeat-x;background-size: .2em .1em;text-shadow: .05em 0 white, -.05em 0 white;&#125; IE6下PNG滤镜透明12345678.tBR &#123; _background:none; _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=true, sizingMethod=image, src="images/topBarRC.png");&#125;/* 注sizingMethod: crop: 剪切图片以适应对象尺寸 image: 默认值。增大或减小对象的尺寸边界以适应图片的尺寸 scale: 缩放图片以适应对象的尺寸边界src: 是图片插入到HTML中的路径，不是插入到CSS文件的路径*/]]></content>
    </entry>

    
  
  
</search>
